import {
  CheckP3Version_default,
  Clear_default,
  Clone_default
} from "./chunk-HBRUMY4U.js";

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/GetParent.js
var GetParent = function(gameObject, name) {
  var parent;
  if (name === void 0) {
    if (gameObject.hasOwnProperty("rexContainer")) {
      parent = gameObject.rexContainer.parent;
    }
  } else {
    parent = GetParent(gameObject);
    while (parent) {
      if (parent.name === name) {
        break;
      }
      parent = GetParent(parent);
    }
  }
  return parent;
};
var GetTopmostParent = function(gameObject) {
  var parent = GetParent(gameObject);
  while (parent) {
    gameObject = parent;
    parent = GetParent(parent);
  }
  return gameObject;
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Base.js
CheckP3Version_default();
var Zone = Phaser.GameObjects.Zone;
var AddItem = Phaser.Utils.Array.Add;
var RemoveItem = Phaser.Utils.Array.Remove;
var Base = class extends Zone {
  constructor(scene, x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    super(scene, x, y, width, height);
    this.children = [];
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (fromScene) {
      var child;
      for (var i = this.children.length - 1; i >= 0; i--) {
        child = this.children[i];
        if (!child.parentContainer && // Not in container
        !child.displayList) {
          child.destroy(fromScene);
        }
      }
    }
    this.clear(!fromScene);
    super.destroy(fromScene);
  }
  contains(gameObject) {
    return this.children.indexOf(gameObject) !== -1;
  }
  add(gameObjects) {
    var parent = this;
    AddItem(
      this.children,
      gameObjects,
      0,
      // Callback of item added
      function(gameObject) {
        gameObject.once("destroy", parent.onChildDestroy, parent);
      },
      this
    );
    return this;
  }
  remove(gameObjects, destroyChild) {
    var parent = this;
    RemoveItem(
      this.children,
      gameObjects,
      // Callback of item removed
      function(gameObject) {
        gameObject.off("destroy", parent.onChildDestroy, parent);
        if (destroyChild) {
          gameObject.destroy();
        }
      }
    );
    return this;
  }
  onChildDestroy(child, fromScene) {
    this.remove(child, false);
  }
  clear(destroyChild) {
    var parent = this;
    var gameObject;
    for (var i = 0, cnt = this.children.length; i < cnt; i++) {
      gameObject = this.children[i];
      gameObject.off("destroy", parent.onChildDestroy, parent);
      if (destroyChild) {
        gameObject.destroy();
      }
    }
    this.children.length = 0;
    return this;
  }
};
var Components = Phaser.GameObjects.Components;
Phaser.Class.mixin(
  Base,
  [
    Components.Alpha,
    Components.Flip
  ]
);
var Base_default = Base;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/utils/GetLocalState.js
var DegToRad = Phaser.Math.DegToRad;
var RadToDeg = Phaser.Math.RadToDeg;
var GetLocalState = function(gameObject) {
  if (!gameObject.hasOwnProperty("rexContainer")) {
    var rexContainer = {
      parent: null,
      self: null,
      layer: null,
      x: 0,
      y: 0,
      syncPosition: true,
      rotation: 0,
      syncRotation: true,
      scaleX: 0,
      scaleY: 0,
      syncScale: true,
      alpha: 0,
      syncAlpha: true,
      syncScrollFactor: true,
      syncCameraFilter: true,
      syncDisplayList: true,
      visible: true,
      active: true
    };
    Object.defineProperty(rexContainer, "angle", {
      get: function() {
        return RadToDeg(this.rotation);
      },
      set: function(value) {
        this.rotation = DegToRad(value);
      }
    });
    Object.defineProperty(rexContainer, "displayWidth", {
      get: function() {
        return gameObject.width * this.scaleX;
      },
      set: function(width) {
        this.scaleX = width / gameObject.width;
      }
    });
    Object.defineProperty(rexContainer, "displayHeight", {
      get: function() {
        return gameObject.height * this.scaleY;
      },
      set: function(height) {
        this.scaleY = height / gameObject.height;
      }
    });
    gameObject.rexContainer = rexContainer;
  }
  return gameObject.rexContainer;
};
var GetLocalState_default = GetLocalState;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Parent.js
var Parent_default = {
  setParent(gameObject, parent) {
    if (parent === void 0) {
      parent = this;
    }
    var localState = GetLocalState_default(gameObject);
    if (parent) {
      localState.parent = parent;
      localState.self = gameObject;
    } else {
      localState.parent = null;
      localState.self = null;
    }
    return this;
  },
  getParent(gameObject, name) {
    if (typeof gameObject === "string") {
      name = gameObject;
      gameObject = void 0;
    }
    if (gameObject === void 0) {
      gameObject = this;
    }
    return GetParent(gameObject, name);
  },
  getTopmostParent(gameObject) {
    if (gameObject === void 0) {
      gameObject = this;
    }
    return GetTopmostParent(gameObject);
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/AddChild.js
var GetValue = Phaser.Utils.Objects.GetValue;
var BaseAdd = Base_default.prototype.add;
var Add = function(gameObject, config) {
  this.setParent(gameObject);
  var state = GetLocalState_default(gameObject);
  SetupSyncFlags(state, config);
  this.resetChildState(gameObject).updateChildVisible(gameObject).updateChildActive(gameObject).updateChildScrollFactor(gameObject).updateChildMask(gameObject).updateCameraFilter(gameObject);
  BaseAdd.call(this, gameObject);
  SyncDisplayList.call(this, gameObject, state);
  return this;
};
var AddLocal = function(gameObject, config) {
  this.setParent(gameObject);
  var state = GetLocalState_default(gameObject);
  SetupSyncFlags(state, config);
  state.x = gameObject.x;
  state.y = gameObject.y;
  state.rotation = gameObject.rotation;
  state.scaleX = gameObject.scaleX;
  state.scaleY = gameObject.scaleY;
  state.alpha = gameObject.alpha;
  state.visible = gameObject.visible;
  state.active = gameObject.active;
  this.updateChildPosition(gameObject).updateChildAlpha(gameObject).updateChildVisible(gameObject).updateChildActive(gameObject).updateChildScrollFactor(gameObject).updateChildMask(gameObject);
  BaseAdd.call(this, gameObject);
  SyncDisplayList.call(this, gameObject, state);
  return this;
};
var SetupSyncFlags = function(state, config) {
  if (config === void 0) {
    config = true;
  }
  if (typeof config === "boolean") {
    state.syncPosition = config;
    state.syncRotation = config;
    state.syncScale = config;
    state.syncAlpha = config;
    state.syncScrollFactor = config;
    state.syncCameraFilter = config;
    state.syncDisplayList = config;
  } else {
    state.syncPosition = GetValue(config, "syncPosition", true);
    state.syncRotation = GetValue(config, "syncRotation", true);
    state.syncScale = GetValue(config, "syncScale", true);
    state.syncAlpha = GetValue(config, "syncAlpha", true);
    state.syncScrollFactor = GetValue(config, "syncScrollFactor", true);
    state.syncCameraFilter = GetValue(config, "syncCameraFilter", true);
    state.syncDisplayList = GetValue(config, "syncDisplayList", true);
  }
};
var SyncDisplayList = function(gameObject, state) {
  this.addToParentContainer(gameObject);
  if (state.syncDisplayList) {
    this.addToPatentLayer(gameObject);
  }
  this.addToRenderLayer(gameObject);
};
var AddChild_default = {
  // Can override this method
  add(gameObject) {
    if (Array.isArray(gameObject)) {
      this.addMultiple(gameObject);
    } else {
      Add.call(this, gameObject);
    }
    return this;
  },
  // Don't override this method
  pin(gameObject, config) {
    if (Array.isArray(gameObject)) {
      this.addMultiple(gameObject, config);
    } else {
      Add.call(this, gameObject, config);
    }
    return this;
  },
  // Can override this method
  addMultiple(gameObjects) {
    var args = Array.from(arguments);
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      args[0] = gameObjects[i];
      this.add.apply(this, args);
    }
    return this;
  },
  addLocal(gameObject) {
    if (Array.isArray(gameObject)) {
      this.addMultiple(gameObject);
    } else {
      AddLocal.call(this, gameObject);
    }
    return this;
  },
  // Don't override this method
  pinLocal(gameObject, config) {
    if (Array.isArray(gameObject)) {
      this.addMultiple(gameObject, config);
    } else {
      AddLocal.call(this, gameObject, config);
    }
    return this;
  },
  addLocalMultiple(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      AddLocal.call(this, gameObjects[i]);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/RemoveChild.js
var BaseRemove = Base_default.prototype.remove;
var BaseClear = Base_default.prototype.clear;
var RemoveChild_default = {
  // Can override this method
  remove(gameObject, destroyChild) {
    if (GetParent(gameObject) !== this) {
      return this;
    }
    this.setParent(gameObject, null);
    if (!destroyChild) {
      this.removeFromRenderLayer(gameObject);
    }
    BaseRemove.call(this, gameObject, destroyChild);
    return this;
  },
  // Don't override this method
  unpin(gameObject, destroyChild) {
    if (GetParent(gameObject) !== this) {
      return this;
    }
    this.setParent(gameObject, null);
    if (!destroyChild) {
      this.removeFromRenderLayer(gameObject);
    }
    BaseRemove.call(this, gameObject, destroyChild);
    return this;
  },
  clear(destroyChild) {
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      this.setParent(child, null);
      if (!destroyChild) {
        this.removeFromRenderLayer(child);
      }
    }
    BaseClear.call(this, destroyChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ChildState.js
var ChildState_default = {
  getLocalState(gameObject) {
    return GetLocalState_default(gameObject);
  },
  resetChildState(gameObject) {
    this.resetChildPositionState(gameObject).resetChildVisibleState(gameObject).resetChildAlphaState(gameObject).resetChildActiveState(gameObject);
    return this;
  },
  resetChildrenState(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      this.resetChildState(gameObjects[i]);
    }
    return this;
  },
  syncProperties() {
    this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Transform.js
var Transform_default = {
  worldToLocal(point) {
    point.x -= this.x;
    point.y -= this.y;
    var c = Math.cos(-this.rotation);
    var s = Math.sin(-this.rotation);
    var tx = point.x;
    var ty = point.y;
    point.x = tx * c - ty * s;
    point.y = tx * s + ty * c;
    point.x /= this.scaleX;
    point.y /= this.scaleY;
    return point;
  },
  localToWorld(point) {
    point.x *= this.scaleX;
    point.y *= this.scaleY;
    var c = Math.cos(this.rotation);
    var s = Math.sin(this.rotation);
    var tx = point.x;
    var ty = point.y;
    point.x = tx * c - ty * s;
    point.y = tx * s + ty * c;
    point.x += this.x;
    point.y += this.y;
    return point;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/utils/GetScale.js
var GetScale = function(a, b) {
  if (a === b) {
    return 1;
  } else {
    return a / b;
  }
};
var GetScale_default = GetScale;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Position.js
var Position_default = {
  updateChildPosition(child) {
    if (child.isRexContainerLite) {
      child.syncChildrenEnable = false;
    }
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    if (localState.syncPosition) {
      child.x = localState.x;
      child.y = localState.y;
      parent.localToWorld(child);
    }
    if (localState.syncRotation) {
      child.rotation = localState.rotation + parent.rotation;
    }
    if (localState.syncScale) {
      child.scaleX = localState.scaleX * parent.scaleX;
      child.scaleY = localState.scaleY * parent.scaleY;
    }
    if (child.isRexContainerLite) {
      child.syncChildrenEnable = true;
      child.syncPosition();
    }
    return this;
  },
  syncPosition() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildPosition, this);
    }
    return this;
  },
  resetChildPositionState(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    localState.x = child.x;
    localState.y = child.y;
    parent.worldToLocal(localState);
    localState.scaleX = GetScale_default(child.scaleX, parent.scaleX);
    localState.scaleY = GetScale_default(child.scaleY, parent.scaleY);
    localState.rotation = child.rotation - parent.rotation;
    return this;
  },
  setChildPosition(child, x, y) {
    child.x = x;
    child.y = y;
    this.resetChildPositionState(child);
    return this;
  },
  setChildLocalPosition(child, x, y) {
    var localState = GetLocalState_default(child);
    localState.x = x;
    localState.y = y;
    this.updateChildPosition(child);
    return this;
  },
  resetLocalPositionState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildPositionState(this);
    }
    return this;
  },
  getChildLocalX(child) {
    var localState = GetLocalState_default(child);
    return localState.x;
  },
  getChildLocalY(child) {
    var localState = GetLocalState_default(child);
    return localState.y;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Rotation.js
var DegToRad2 = Phaser.Math.DegToRad;
var Rotation_default = {
  updateChildRotation(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    if (localState.syncRotation) {
      child.rotation = parent.rotation + localState.rotation;
    }
    return this;
  },
  syncRotation() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildRotation, this);
    }
    return this;
  },
  resetChildRotationState(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    localState.rotation = child.rotation - parent.rotation;
    return this;
  },
  setChildRotation(child, rotation) {
    child.rotation = rotation;
    this.resetChildRotationState(child);
    return this;
  },
  setChildAngle(child, angle) {
    child.angle = angle;
    this.resetChildRotationState(child);
    return this;
  },
  setChildLocalRotation(child, rotation) {
    var localState = GetLocalState_default(child);
    localState.rotation = rotation;
    this.updateChildRotation(child);
    return this;
  },
  setChildLocalAngle(child, angle) {
    var localState = GetLocalState_default(child);
    localState.rotation = DegToRad2(angle);
    this.updateChildRotation(child);
    return this;
  },
  resetLocalRotationState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildRotationState(this);
    }
    return this;
  },
  getChildLocalRotation(child) {
    var localState = GetLocalState_default(child);
    return localState.rotation;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Scale.js
var Scale_default = {
  updateChildScale(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    if (state.syncScale) {
      child.scaleX = parent.scaleX * state.scaleX;
      child.scaleY = parent.scaleY * state.scaleY;
    }
    return this;
  },
  syncScale() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildScale, this);
    }
    return this;
  },
  resetChildScaleState(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    state.scaleX = GetScale_default(child.scaleX, parent.scaleX);
    state.scaleY = GetScale_default(child.scaleY, parent.scaleY);
    return this;
  },
  setChildScale(child, scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    child.scaleX = scaleX;
    child.scaleY = scaleY;
    this.resetChildScaleState(child);
    return this;
  },
  setChildLocalScale(child, scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    var state = GetLocalState_default(child);
    state.scaleX = scaleX;
    state.scaleY = scaleY;
    this.updateChildScale(child);
    return this;
  },
  setChildDisplaySize(child, width, height) {
    child.setDisplaySize(width, height);
    this.resetChildScaleState(child);
    return this;
  },
  resetLocalScaleState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildScaleState(this);
    }
    return this;
  },
  getChildLocalScaleX(child) {
    var localState = GetLocalState_default(child);
    return localState.scaleX;
  },
  getChildLocalScaleY(child) {
    var localState = GetLocalState_default(child);
    return localState.scaleY;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Visible.js
var Visible_default = {
  updateChildVisible(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    var maskVisible = localState.hasOwnProperty("maskVisible") ? localState.maskVisible : true;
    var parentVisible = parent ? parent.visible : true;
    child.visible = parentVisible && localState.visible && maskVisible;
    return this;
  },
  syncVisible() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildVisible, this);
    }
    return this;
  },
  resetChildVisibleState(child) {
    var localState = GetLocalState_default(child);
    if (localState.hasOwnProperty("maskVisible")) {
      delete localState.maskVisible;
    }
    localState.visible = child.visible;
    return this;
  },
  setChildVisible(child, visible) {
    this.setChildLocalVisible(child, visible);
    return this;
  },
  // Internal method
  setChildLocalVisible(child, visible) {
    if (visible === void 0) {
      visible = true;
    }
    var localState = GetLocalState_default(child);
    localState.visible = visible;
    this.updateChildVisible(child);
    return this;
  },
  // Internal method
  setChildMaskVisible(child, visible) {
    if (visible === void 0) {
      visible = true;
    }
    var localState = GetLocalState_default(child);
    localState.maskVisible = visible;
    this.updateChildVisible(child);
    return this;
  },
  resetLocalVisibleState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildVisibleState(this);
    }
    return this;
  },
  getChildLocalVisible(child) {
    var localState = GetLocalState_default(child);
    return localState.visible;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Alpha.js
var Alpha_default = {
  updateChildAlpha(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    if (state.syncAlpha) {
      child.alpha = parent.alpha * state.alpha;
    }
    return this;
  },
  syncAlpha() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildAlpha, this);
    }
    return this;
  },
  resetChildAlphaState(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    state.alpha = GetScale_default(child.alpha, parent.alpha);
    return this;
  },
  setChildAlpha(child, alpha) {
    child.alpha = alpha;
    this.resetChildAlphaState(child);
    return this;
  },
  setChildLocalAlpha(child, alpha) {
    var state = GetLocalState_default(child);
    state.alpha = alpha;
    this.updateChildAlpha(child);
    return this;
  },
  resetLocalAlphaState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildAlphaState(this);
    }
    return this;
  },
  getChildLocalAlpha(child) {
    var localState = GetLocalState_default(child);
    return localState.alpha;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Active.js
var Active_default = {
  updateChildActive(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    child.active = parent.active && localState.active;
    return this;
  },
  syncActive() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildActive, this);
    }
    return this;
  },
  resetChildActiveState(child) {
    var localState = GetLocalState_default(child);
    localState.active = child.active;
    return this;
  },
  setChildActive(child, active) {
    child.active = active;
    this.resetChildActiveState(child);
    return this;
  },
  setChildLocalActive(child, active) {
    if (active === void 0) {
      active = true;
    }
    var localState = GetLocalState_default(child);
    localState.active = active;
    this.updateChildActive(child);
    return this;
  },
  resetLocalActiveState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildActiveState(this);
    }
    return this;
  },
  getChildLocalActive(child) {
    var localState = GetLocalState_default(child);
    return localState.active;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ScrollFactor.js
var ScrollFactor_default = {
  updateChildScrollFactor(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    if (localState.syncScrollFactor) {
      child.scrollFactorX = parent.scrollFactorX;
      child.scrollFactorY = parent.scrollFactorY;
    }
    return this;
  },
  syncScrollFactor() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildScrollFactor, this);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/CameraFilter.js
var CameraFilter_default = {
  updateCameraFilter(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    if (state.syncCameraFilter) {
      child.cameraFilter = parent.cameraFilter;
    }
    return this;
  },
  syncCameraFilter() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateCameraFilter, this);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Mask.js
var Mask_default = {
  updateChildMask(child) {
    if (this.mask == null) {
      return this;
    }
    var maskGameObject = this.mask.hasOwnProperty("geometryMask") ? this.mask.geometryMask : this.mask.bitmapMask;
    if (maskGameObject !== child) {
      child.mask = this.mask;
    }
    return this;
  },
  syncMask() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildMask, this);
    }
    return this;
  },
  setMask(mask) {
    this.mask = mask;
    return this;
  },
  clearMask(destroyMask) {
    if (destroyMask === void 0) {
      destroyMask = false;
    }
    var self = this;
    this._mask = null;
    this.setChildMaskVisible(this);
    this.children.forEach(function(child) {
      if (child.clearMask) {
        child.clearMask(false);
      }
      if (!child.hasOwnProperty("isRexContainerLite")) {
        self.setChildMaskVisible(child);
      }
    });
    if (destroyMask && this.mask) {
      this.mask.destroy();
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/system/SortGameObjectsByDepth.js
var SortGameObjectsByDepth = function(gameObjects, descending) {
  if (gameObjects.length <= 1) {
    return gameObjects;
  }
  if (descending === void 0) {
    descending = false;
  }
  var itemList;
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var gameObject = gameObjects[i];
    if (gameObject.displayList) {
      itemList = gameObject.displayList;
    } else if (gameObject.parentContainer) {
      itemList = gameObject.parentContainer.list;
    }
    if (itemList) {
      break;
    }
  }
  if (!itemList) {
    itemList = gameObject.scene.sys.displayList;
  }
  if (itemList.depthSort) {
    itemList.depthSort();
    itemList = itemList.list;
  }
  if (descending) {
    gameObjects.sort(function(childA, childB) {
      return itemList.indexOf(childB) - itemList.indexOf(childA);
    });
  } else {
    gameObjects.sort(function(childA, childB) {
      return itemList.indexOf(childA) - itemList.indexOf(childB);
    });
  }
  return gameObjects;
};
var SortGameObjectsByDepth_default = SortGameObjectsByDepth;

// node_modules/phaser3-rex-plugins/plugins/utils/system/FilterDisplayGameObjects.js
var FilterDisplayGameObjects = function(gameObjects) {
  return gameObjects.filter(function(gameObject) {
    if (gameObject.displayList) {
      return true;
    } else if (gameObject.parentContainer) {
      return true;
    }
  });
};
var FilterDisplayGameObjects_default = FilterDisplayGameObjects;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Depth.js
var Depth_default = {
  setDepth(value, containerOnly) {
    this.depth = value;
    if (!containerOnly && this.children) {
      var children = this.getAllChildren();
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].depth = value;
      }
    }
    return this;
  },
  swapDepth(containerB) {
    var depthA = this.depth;
    var depthB = containerB.depth;
    this.setDepth(depthB);
    containerB.setDepth(depthA);
    return this;
  },
  incDepth(inc) {
    this.depth += inc;
    if (this.children) {
      var children = this.getAllChildren();
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].depth += inc;
      }
    }
    return this;
  },
  bringToTop() {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, false);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.bringToTop(child);
      }
    }
    return this;
  },
  bringMeToTop() {
    return this.bringToTop();
  },
  sendToBack() {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, true);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.sendToBack(child);
      }
    }
    return this;
  },
  sendMeToBack() {
    return this.sendToBack();
  },
  moveDepthBelow(gameObject) {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    if (gameObject.displayList !== displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, false);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.moveBelow(gameObject, child);
        break;
      }
    }
    return this;
  },
  moveMyDepthBelow(gameObject) {
    return this.moveDepthBelow(gameObject);
  },
  moveDepthAbove(gameObject) {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    if (gameObject.displayList !== displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, true);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.moveAbove(gameObject, child);
        break;
      }
    }
    return this;
  },
  moveMyDepthAbove(gameObject) {
    return this.moveDepthAbove(gameObject);
  },
  bringChildToTop(child) {
    var gameObjects;
    if (child !== this && child.isRexContainerLite) {
      gameObjects = child.getAllChildren([child]);
      gameObjects = FilterDisplayGameObjects_default(gameObjects);
      gameObjects = SortGameObjectsByDepth_default(gameObjects, false);
    } else {
      gameObjects = [child];
    }
    var children = this.getAllChildren([this]);
    children = FilterDisplayGameObjects_default(children);
    children = SortGameObjectsByDepth_default(children, false);
    var topChild = children[children.length - 1];
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject = gameObjects[i];
      if (topChild === gameObject) {
        continue;
      }
      if (gameObject !== this && topChild.displayList !== gameObject.displayList) {
        continue;
      }
      topChild.displayList.moveAbove(gameObject, topChild);
      topChild = gameObject;
    }
    return this;
  },
  sendChildToBack(child) {
    var gameObjects;
    if (child !== this && child.isRexContainerLite) {
      gameObjects = child.getAllChildren([child]);
      gameObjects = FilterDisplayGameObjects_default(gameObjects);
      gameObjects = SortGameObjectsByDepth_default(gameObjects, false);
    } else {
      gameObjects = [child];
    }
    var children = this.getAllChildren([this]);
    children = FilterDisplayGameObjects_default(children);
    children = SortGameObjectsByDepth_default(children, false);
    var bottomChild = children[0];
    for (var i = gameObjects.length - 1; i >= 0; i--) {
      var gameObject = gameObjects[i];
      if (bottomChild === gameObject) {
        continue;
      }
      if (gameObject !== this && bottomChild.displayList !== gameObject.displayList) {
        continue;
      }
      bottomChild.displayList.moveBelow(gameObject, bottomChild);
      bottomChild = gameObject;
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/utils/Traversal.js
var DepthFirstSearch = function(root, callback) {
  var skip = callback(root);
  if (!skip && root.isRexContainerLite) {
    var children = root.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      DepthFirstSearch(children[i], callback);
    }
  }
};
var BreadthFirstSearch = function(root, callback) {
  var queue = [root];
  while (queue.length > 0) {
    var current = queue.shift();
    var skip = callback(current);
    if (!skip && current.isRexContainerLite) {
      queue.push(...current.children);
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Children.js
var ArrayUtils = Phaser.Utils.Array;
var Children_default = {
  getChildren(out) {
    if (!out) {
      out = this.children;
    } else {
      for (var i = 0, cnt = this.children.length; i < cnt; i++) {
        out.push(this.children[i]);
      }
    }
    return out;
  },
  getAllChildren(out) {
    if (out === void 0) {
      out = [];
    }
    var root = this;
    BreadthFirstSearch(root, function(child) {
      if (child === root) {
        return;
      }
      out.push(child);
    });
    return out;
  },
  getAllVisibleChildren(out) {
    if (out === void 0) {
      out = [];
    }
    var root = this;
    BreadthFirstSearch(root, function(child) {
      if (child === root) {
        return;
      }
      if (!child.visible) {
        return true;
      }
      out.push(child);
    });
    return out;
  },
  bfs(callback, root) {
    if (root === void 0) {
      root = this;
    }
    BreadthFirstSearch(root, callback);
    return this;
  },
  dfs(callback, root) {
    if (root === void 0) {
      root = this;
    }
    DepthFirstSearch(root, callback);
    return this;
  },
  contains(gameObject) {
    var parent = GetParent(gameObject);
    if (!parent) {
      return false;
    } else if (parent === this) {
      return true;
    } else {
      return this.contains(parent);
    }
  },
  getByName(name, recursive) {
    if (!recursive) {
      return ArrayUtils.GetFirst(this.children, "name", name);
    } else {
      var queue = [this];
      var parent, child;
      while (queue.length) {
        parent = queue.shift();
        for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
          child = parent.children[i];
          if (child.name === name) {
            return child;
          } else if (child.isRexContainerLite) {
            queue.push(child);
          }
        }
      }
      return null;
    }
  },
  getRandom(startIndex, length) {
    return ArrayUtils.GetRandom(this.children, startIndex, length);
  },
  getFirst(property, value, startIndex, endIndex) {
    return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
  },
  getAll(property, value, startIndex, endIndex) {
    return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
  },
  count(property, value, startIndex, endIndex) {
    return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
  },
  swap(child1, child2) {
    ArrayUtils.Swap(this.children, child1, child2);
    return this;
  },
  setAll(property, value, startIndex, endIndex) {
    ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Tween.js
var GetLocalStates = function(gameObjects) {
  var localStates = [];
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var gameObject = gameObjects[i];
    if (!gameObject.hasOwnProperty("rexContainer")) {
      continue;
    }
    localStates.push(gameObject.rexContainer);
  }
  return localStates;
};
var GetScene = function(gameObjects) {
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var scene = gameObjects[i].scene;
    if (scene) {
      return scene;
    }
  }
  return null;
};
var UpdateChild = function(tween, key2, target) {
  if (!target.parent) {
    tween.remove();
    return;
  }
  var parent = target.parent;
  var child = target.self;
  switch (key2) {
    case "x":
    case "y":
      parent.updateChildPosition(child);
      break;
    case "angle":
    case "rotation":
      parent.updateChildRotation(child);
      break;
    case "scaleX":
    case "scaleY":
    case "displayWidth":
    case "displayHeight":
      parent.updateChildScale(child);
      break;
    case "alpha":
      parent.updateChildAlpha(child);
      break;
    default:
      parent.updateChildPosition(child);
      parent.updateChildRotation(child);
      parent.updateChildScale(child);
      parent.updateChildAlpha(child);
      break;
  }
};
var Tween_default = {
  tweenChild(tweenConfig) {
    var targets = tweenConfig.targets;
    if (!Array.isArray(targets)) {
      targets = [targets];
    }
    var scene = this.scene || GetScene(targets);
    if (!scene) {
      return;
    }
    tweenConfig.targets = GetLocalStates(targets);
    var tween = scene.tweens.add(tweenConfig);
    tween.on("update", UpdateChild);
    return tween;
  },
  tweenSelf(tweenConfig) {
    tweenConfig.targets = [this];
    return this.tweenChild(tweenConfig);
  },
  createTweenChildConfig(tweenConfig) {
    var targets = tweenConfig.targets;
    if (targets) {
      if (!Array.isArray(targets)) {
        targets = [targets];
      }
      tweenConfig.targets = GetLocalStates(targets);
    }
    var onUpdate = tweenConfig.onUpdate;
    tweenConfig.onUpdate = function(tween, target) {
      if (onUpdate) {
        onUpdate(tween, target);
      }
      UpdateChild(tween, void 0, target);
    };
    return tweenConfig;
  },
  tween(tweenConfig) {
    var scene = this.scene;
    if (!tweenConfig.targets) {
      tweenConfig.targets = this;
    }
    return scene.tweens.add(tweenConfig);
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsContainerGameObject.js
var ContainerClass = Phaser.GameObjects.Container;
var IsContainerGameObject = function(gameObject) {
  return gameObject instanceof ContainerClass;
};
var IsContainerGameObject_default = IsContainerGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsLayerGameObject.js
var LayerClass = Phaser.GameObjects.Layer;
var IsLayerGameObject = function(gameObject) {
  return gameObject instanceof LayerClass;
};
var IsLayerGameObject_default = IsLayerGameObject;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/P3Container.js
var GetValidChildren = function(parent) {
  var children = parent.getAllChildren([parent]);
  children = children.filter(function(gameObject) {
    return !!gameObject.displayList || // At scene's displayList or at a layer
    !!gameObject.parentContainer;
  });
  return children;
};
var AddToContainer = function(p3Container) {
  var gameObjects = GetValidChildren(this);
  if (gameObjects.indexOf(this) === -1) {
    gameObjects.push(this);
  }
  SortGameObjectsByDepth_default(gameObjects);
  p3Container.add(gameObjects);
};
var RemoveFromContainer = function(p3Container, descending, addToScene) {
  if (!this.scene) {
    return;
  }
  var gameObjects = GetValidChildren(this);
  SortGameObjectsByDepth_default(gameObjects, descending);
  p3Container.remove(gameObjects);
  if (addToScene) {
    gameObjects.forEach(function(gameObject) {
      gameObject.addToDisplayList();
    });
  }
};
var P3Container_default = {
  addToContainer(p3Container) {
    if (!IsContainerGameObject_default(p3Container)) {
      return this;
    }
    this._setParentContainerFlag = true;
    AddToContainer.call(this, p3Container);
    this._setParentContainerFlag = false;
    return this;
  },
  addToLayer(layer) {
    if (!IsLayerGameObject_default(layer)) {
      return this;
    }
    AddToContainer.call(this, layer);
    return this;
  },
  removeFromContainer() {
    if (!this.parentContainer) {
      return this;
    }
    this._setParentContainerFlag = true;
    RemoveFromContainer.call(this, this.parentContainer, true, false);
    this._setParentContainerFlag = false;
    return this;
  },
  removeFromLayer(addToScene) {
    if (addToScene === void 0) {
      addToScene = true;
    }
    if (!IsLayerGameObject_default(this.displayList)) {
      return this;
    }
    RemoveFromContainer.call(this, this.displayList, false, addToScene);
    return this;
  },
  getParentContainer() {
    if (this.parentContainer) {
      return this.parentContainer;
    }
    var parent = this.getParent();
    while (parent) {
      var p3Container = parent.parentContainer;
      if (p3Container) {
        return p3Container;
      }
      parent = parent.getParent();
    }
    return null;
  },
  addToParentContainer(gameObject) {
    if (!gameObject.displayList) {
      return this;
    }
    var p3Container = this.getParentContainer();
    if (!p3Container) {
      return this;
    }
    if (gameObject.isRexContainerLite) {
      gameObject.addToContainer(p3Container);
    } else {
      p3Container.add(gameObject);
    }
    return this;
  },
  addToPatentLayer(gameObject) {
    if (!gameObject.displayList) {
      return this;
    }
    var parentLayer = this.displayList;
    if (parentLayer === gameObject.displayList) {
      return this;
    }
    if (IsLayerGameObject_default(parentLayer)) {
      if (gameObject.isRexContainerLite) {
        gameObject.addToLayer(parentLayer);
      } else {
        parentLayer.add(gameObject);
      }
    } else {
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/RenderLayer.js
var RenderLayer_default = {
  hasLayer() {
    return !!this.privateRenderLayer;
  },
  enableLayer() {
    if (this.hasLayer()) {
      return this;
    }
    var layer = this.scene.add.layer();
    this.moveDepthBelow(layer);
    this.addToLayer(layer);
    this.privateRenderLayer = layer;
    return this;
  },
  getLayer() {
    if (!this.hasLayer()) {
      this.enableLayer();
    }
    return this.privateRenderLayer;
  },
  getRenderLayer() {
    if (this.hasLayer()) {
      return this.privateRenderLayer;
    }
    var parent = this.getParent();
    while (parent) {
      var layer = parent.privateRenderLayer;
      if (layer) {
        return layer;
      }
      parent = parent.getParent();
    }
    return null;
  },
  // Internal method for adding child
  addToRenderLayer(gameObject) {
    if (!gameObject.displayList) {
      return this;
    }
    var layer = this.getRenderLayer();
    if (!layer) {
      return this;
    }
    if (layer === gameObject.displayList) {
      return this;
    }
    if (gameObject.isRexContainerLite) {
      gameObject.addToLayer(layer);
    } else {
      layer.add(gameObject);
    }
    var state = GetLocalState_default(gameObject);
    state.layer = layer;
    return this;
  },
  // Internal method for removing child
  removeFromRenderLayer(gameObject) {
    var state = GetLocalState_default(gameObject);
    var layer = state.layer;
    if (!layer) {
      return this;
    }
    if (gameObject.isRexContainerLite) {
      gameObject.removeFromLayer(true);
    } else {
      layer.remove(gameObject);
    }
    state.layer = null;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/size/GetDisplaySize.js
var GetDisplayWidth = function(gameObject) {
  if (gameObject.displayWidth !== void 0) {
    return gameObject.displayWidth;
  } else {
    return gameObject.width;
  }
};
var GetDisplayHeight = function(gameObject) {
  if (gameObject.displayHeight !== void 0) {
    return gameObject.displayHeight;
  } else {
    return gameObject.height;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/GetBounds.js
var Rectangle = Phaser.Geom.Rectangle;
var Vector2 = Phaser.Math.Vector2;
var RotateAround = Phaser.Math.RotateAround;
var P3Container = Phaser.GameObjects.Container;
var GetBounds = function(gameObject, output) {
  if (output === void 0) {
    output = new Rectangle();
  } else if (output === true) {
    if (GlobRect === void 0) {
      GlobRect = new Rectangle();
    }
    output = GlobRect;
  }
  if (gameObject.getBounds && !(gameObject instanceof P3Container)) {
    return gameObject.getBounds(output);
  }
  var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
  if (gameObject.parentContainer) {
    var parentMatrix2 = gameObject.parentContainer.getBoundsTransformMatrix();
    GetTopLeft(gameObject, output);
    parentMatrix2.transformPoint(output.x, output.y, output);
    TLx = output.x;
    TLy = output.y;
    GetTopRight(gameObject, output);
    parentMatrix2.transformPoint(output.x, output.y, output);
    TRx = output.x;
    TRy = output.y;
    GetBottomLeft(gameObject, output);
    ;
    parentMatrix2.transformPoint(output.x, output.y, output);
    BLx = output.x;
    BLy = output.y;
    GetBottomRight(gameObject, output);
    parentMatrix2.transformPoint(output.x, output.y, output);
    BRx = output.x;
    BRy = output.y;
  } else {
    GetTopLeft(gameObject, output);
    TLx = output.x;
    TLy = output.y;
    GetTopRight(gameObject, output);
    ;
    TRx = output.x;
    TRy = output.y;
    GetBottomLeft(gameObject, output);
    ;
    BLx = output.x;
    BLy = output.y;
    GetBottomRight(gameObject, output);
    BRx = output.x;
    BRy = output.y;
  }
  output.x = Math.min(TLx, TRx, BLx, BRx);
  output.y = Math.min(TLy, TRy, BLy, BRy);
  output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
  output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
  return output;
};
var GlobRect = void 0;
var GetTopLeft = function(gameObject, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject.getTopLeft) {
    return gameObject.getTopLeft(output);
  }
  output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
  output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
  return PrepareBoundsOutput(gameObject, output, includeParent);
};
var GetTopRight = function(gameObject, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject.getTopRight) {
    return gameObject.getTopRight(output);
  }
  output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
  output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
  return PrepareBoundsOutput(gameObject, output, includeParent);
};
var GetBottomLeft = function(gameObject, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject.getBottomLeft) {
    return gameObject.getBottomLeft(output);
  }
  output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
  output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
  return PrepareBoundsOutput(gameObject, output, includeParent);
};
var GetBottomRight = function(gameObject, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject.getBottomRight) {
    return gameObject.getBottomRight(output);
  }
  output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
  output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
  return PrepareBoundsOutput(gameObject, output, includeParent);
};
var GetCenter = function(gameObject, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  var displayWidth = GetDisplayWidth(gameObject);
  var displayHeight = GetDisplayHeight(gameObject);
  output.x = gameObject.x + displayWidth * (0.5 - gameObject.originX);
  output.y = gameObject.y + displayHeight * (0.5 - gameObject.originY);
  return PrepareBoundsOutput(gameObject, output, includeParent);
};
var GlobVector = void 0;
var PrepareBoundsOutput = function(gameObject, output, includeParent) {
  if (includeParent === void 0) {
    includeParent = false;
  }
  if (gameObject.rotation !== 0) {
    RotateAround(output, gameObject.x, gameObject.y, gameObject.rotation);
  }
  if (includeParent && gameObject.parentContainer) {
    var parentMatrix2 = gameObject.parentContainer.getBoundsTransformMatrix();
    parentMatrix2.transformPoint(output.x, output.y, output);
  }
  return output;
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/GetBoundsOfGameObjects.js
var Rectangle2 = Phaser.Geom.Rectangle;
var Union = Phaser.Geom.Rectangle.Union;
var GetBoundsOfGameObjects = function(gameObjects, out) {
  if (out === void 0) {
    out = new Rectangle2();
  } else if (out === true) {
    if (GlobRect2 === void 0) {
      GlobRect2 = new Rectangle2();
    }
    out = GlobRect2;
  }
  out.setTo(0, 0, 0, 0);
  var gameObject;
  var firstClone = true;
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    gameObject = gameObjects[i];
    if (!gameObject.getBounds) {
      continue;
    }
    var boundsRect = GetBounds(gameObject, true);
    if (firstClone) {
      out.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
      firstClone = false;
    } else {
      Union(boundsRect, out, out);
    }
  }
  return out;
};
var GlobRect2;
var GetBoundsOfGameObjects_default = GetBoundsOfGameObjects;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsGameObject.js
var GameObjectClass = Phaser.GameObjects.GameObject;
var LayerClass2 = Phaser.GameObjects.Layer;
var IsGameObject = function(object) {
  return object instanceof GameObjectClass || object instanceof LayerClass2;
};
var IsGameObject_default = IsGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/rendertexture/Snapshot.js
var GetValue2 = Phaser.Utils.Objects.GetValue;
var Snapshot = function(config) {
  if (!config) {
    return;
  }
  var gameObjects = config.gameObjects;
  var renderTexture = config.renderTexture;
  var saveTexture = config.saveTexture;
  var x = GetValue2(config, "x", void 0);
  var y = GetValue2(config, "y", void 0);
  var width = GetValue2(config, "width", void 0);
  var height = GetValue2(config, "height", void 0);
  var originX = GetValue2(config, "originX", 0);
  var originY = GetValue2(config, "originY", 0);
  var padding = GetValue2(config, "padding", 0);
  var scrollX, scrollY;
  if (width === void 0 || height === void 0 || x === void 0 || y === void 0) {
    var bounds = GetBoundsOfGameObjects_default(gameObjects, true);
    var isCenterOrigin = x !== void 0 && y !== void 0;
    if (isCenterOrigin) {
      width = Math.max(x - bounds.left, bounds.right - x) * 2;
      height = Math.max(y - bounds.top, bounds.bottom - y) * 2;
      originX = 0.5;
      originY = 0.5;
    } else {
      x = bounds.x;
      y = bounds.y;
      width = bounds.width;
      height = bounds.height;
      originX = 0;
      originY = 0;
    }
    scrollX = bounds.x;
    scrollY = bounds.y;
  } else {
    scrollX = x + (0 - originX) * width;
    scrollY = y + (0 - originY) * height;
  }
  scrollX -= padding;
  scrollY -= padding;
  width += padding * 2;
  height += padding * 2;
  var scene = gameObjects[0].scene;
  var textureManager = scene.sys.textures;
  if (saveTexture && !renderTexture) {
    renderTexture = textureManager.addDynamicTexture(saveTexture, width, height);
  }
  if (!renderTexture) {
    renderTexture = scene.add.renderTexture(0, 0, width, height);
  }
  if (renderTexture.setPosition) {
    renderTexture.setPosition(x, y);
  }
  if (renderTexture.width !== width || renderTexture.height !== height) {
    renderTexture.setSize(width, height);
  }
  if (renderTexture.setOrigin) {
    renderTexture.setOrigin(originX, originY);
  }
  renderTexture.camera.setScroll(scrollX, scrollY);
  gameObjects = SortGameObjectsByDepth_default(Clone_default(gameObjects));
  renderTexture.draw(gameObjects);
  if (saveTexture) {
    if (IsGameObject_default(renderTexture)) {
      renderTexture.saveTexture(saveTexture);
    } else if (renderTexture.key !== saveTexture) {
      textureManager.renameTexture(renderTexture.key, key);
    }
  }
  return renderTexture;
};
var Snapshot_default = Snapshot;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/RenderTexture.js
var RenderTexture_default = {
  snapshot(config) {
    var scaleXSave = this.scaleX;
    var scaleYSave = this.scaleY;
    var scale1 = scaleXSave === 1 && scaleYSave === 1;
    if (!scale1) {
      this.setScale(1);
    }
    if (config === void 0) {
      config = {};
    }
    config.gameObjects = this.getAllVisibleChildren();
    config.x = this.x;
    config.y = this.y;
    config.originX = this.originX;
    config.originY = this.originY;
    var rt = Snapshot_default(config);
    var isValidRT = !!rt.scene;
    if (!scale1) {
      this.setScale(scaleXSave, scaleYSave);
      if (isValidRT) {
        rt.setScale(scaleXSave, scaleYSave);
      }
    }
    return isValidRT ? rt : this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/DrawBounds.js
var GetValue3 = Phaser.Utils.Objects.GetValue;
var DrawBounds = function(gameObjects, graphics, config) {
  var strokeColor, lineWidth, fillColor, fillAlpha, padding;
  if (typeof config === "number") {
    strokeColor = config;
  } else {
    strokeColor = GetValue3(config, "color");
    lineWidth = GetValue3(config, "lineWidth");
    fillColor = GetValue3(config, "fillColor");
    fillAlpha = GetValue3(config, "fillAlpha", 1);
    padding = GetValue3(config, "padding", 0);
  }
  if (Array.isArray(gameObjects)) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      Draw(gameObjects[i], graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
    }
  } else {
    Draw(gameObjects, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
  }
};
var Draw = function(gameObject, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding) {
  var canDrawBound = gameObject.getBounds || gameObject.width !== void 0 && gameObject.height !== void 0;
  if (!canDrawBound) {
    return;
  }
  if (strokeColor === void 0) {
    strokeColor = 16777215;
  }
  if (lineWidth === void 0) {
    lineWidth = 1;
  }
  if (fillColor === void 0) {
    fillColor = null;
  }
  ;
  if (fillAlpha === void 0) {
    fillAlpha = 1;
  }
  ;
  if (padding === void 0) {
    padding = 0;
  }
  var p0 = GetTopLeft(gameObject, Points[0]);
  p0.x -= padding;
  p0.y -= padding;
  var p1 = GetTopRight(gameObject, Points[1]);
  p1.x += padding;
  p1.y -= padding;
  var p2 = GetBottomRight(gameObject, Points[2]);
  p2.x += padding;
  p2.y += padding;
  var p3 = GetBottomLeft(gameObject, Points[3]);
  p3.x -= padding;
  p3.y += padding;
  if (fillColor !== null) {
    graphics.fillStyle(fillColor, fillAlpha).fillPoints(Points, true, true);
  }
  if (strokeColor !== null) {
    graphics.lineStyle(lineWidth, strokeColor).strokePoints(Points, true, true);
  }
};
var Points = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];
var DrawBounds_default = DrawBounds;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/DrawBounds.js
var GetValue4 = Phaser.Utils.Objects.GetValue;
var DrawBounds2 = function(graphics, config) {
  var drawContainer = GetValue4(config, "drawContainer", true);
  var gameObjects = GetValue4(config, "children");
  if (gameObjects === void 0) {
    gameObjects = this.getAllVisibleChildren([this]);
  }
  if (!drawContainer) {
    gameObjects = gameObjects.filter(function(gameObject) {
      return !gameObject.isRexContainerLite;
    });
  }
  DrawBounds_default(gameObjects, graphics, config);
  return this;
};
var DrawBounds_default2 = DrawBounds2;

// node_modules/phaser3-rex-plugins/plugins/utils/origin/ChangeOrigin.js
var RotateAround2 = Phaser.Math.RotateAround;
var ChangeOrigin = function(gameObject, originX, originY) {
  if (originY === void 0) {
    originY = originX;
  }
  var deltaXY = {
    x: (originX - gameObject.originX) * gameObject.displayWidth,
    y: (originY - gameObject.originY) * gameObject.displayHeight
  };
  RotateAround2(deltaXY, 0, 0, gameObject.rotation);
  gameObject.originX = originX;
  gameObject.originY = originY;
  gameObject.x = gameObject.x + deltaXY.x;
  gameObject.y = gameObject.y + deltaXY.y;
  return gameObject;
};
var ChangeOrigin_default = ChangeOrigin;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ChangeOrigin.js
var ChangeOrigin2 = function(originX, originY) {
  this.syncChildrenEnable = false;
  ChangeOrigin_default(this, originX, originY);
  this.syncChildrenEnable = true;
  var children = this.getAllChildren();
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    this.resetChildPositionState(children[i]);
  }
  return this;
};
var ChangeOrigin_default2 = ChangeOrigin2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Methods.js
var methods = {
  changeOrigin: ChangeOrigin_default2,
  drawBounds: DrawBounds_default2
};
Object.assign(
  methods,
  Parent_default,
  AddChild_default,
  RemoveChild_default,
  ChildState_default,
  Transform_default,
  Position_default,
  Rotation_default,
  Scale_default,
  Visible_default,
  Alpha_default,
  Active_default,
  ScrollFactor_default,
  CameraFilter_default,
  Mask_default,
  Depth_default,
  Children_default,
  Tween_default,
  P3Container_default,
  RenderLayer_default,
  RenderTexture_default
);
var Methods_default = methods;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ContainerLite.js
var ContainerLite = class extends Base_default {
  constructor(scene, x, y, width, height, children) {
    if (Array.isArray(width)) {
      children = width;
      width = void 0;
      height = void 0;
    }
    super(scene, x, y, width, height);
    this.type = "rexContainerLite";
    this.isRexContainerLite = true;
    this.syncChildrenEnable = true;
    this._active = true;
    this._mask = null;
    this._scrollFactorX = 1;
    this._scrollFactorY = 1;
    this._cameraFilter = 0;
    this.privateRenderLayer = void 0;
    if (children) {
      this.add(children);
    }
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.syncChildrenEnable = false;
    super.destroy(fromScene);
    if (this.privateRenderLayer && this.privateRenderLayer.scene) {
      this.privateRenderLayer.list.length = 0;
      this.privateRenderLayer.destroy();
    }
  }
  resize(width, height) {
    this.setSize(width, height);
    return this;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x === value) {
      return;
    }
    this._x = value;
    this.syncPosition();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y === value) {
      return;
    }
    this._y = value;
    this.syncPosition();
  }
  // Override
  get rotation() {
    return super.rotation;
  }
  set rotation(value) {
    if (this.rotation === value) {
      return;
    }
    super.rotation = value;
    this.syncPosition();
  }
  // Override
  get scaleX() {
    return super.scaleX;
  }
  set scaleX(value) {
    if (this.scaleX === value) {
      return;
    }
    super.scaleX = value;
    this.syncPosition();
  }
  // Override
  get scaleY() {
    return super.scaleY;
  }
  set scaleY(value) {
    if (this.scaleY === value) {
      return;
    }
    super.scaleY = value;
    this.syncPosition();
  }
  // Override
  get scale() {
    return super.scale;
  }
  set scale(value) {
    if (this.scale === value) {
      return;
    }
    super.scale = value;
    this.syncPosition();
  }
  // Override
  get visible() {
    return super.visible;
  }
  set visible(value) {
    if (super.visible === value) {
      return;
    }
    super.visible = value;
    this.syncVisible();
  }
  // Override
  get alpha() {
    return super.alpha;
  }
  set alpha(value) {
    if (super.alpha === value) {
      return;
    }
    super.alpha = value;
    this.syncAlpha();
  }
  // Override
  get active() {
    return this._active;
  }
  set active(value) {
    if (this._active === value) {
      return;
    }
    this._active = value;
    this.syncActive();
  }
  // Override
  get mask() {
    return this._mask;
  }
  set mask(mask) {
    if (this._mask === mask) {
      return;
    }
    this._mask = mask;
    this.syncMask();
  }
  // Override
  get scrollFactorX() {
    return this._scrollFactorX;
  }
  set scrollFactorX(value) {
    if (this._scrollFactorX === value) {
      return;
    }
    this._scrollFactorX = value;
    this.syncScrollFactor();
  }
  get scrollFactorY() {
    return this._scrollFactorY;
  }
  set scrollFactorY(value) {
    if (this._scrollFactorY === value) {
      return;
    }
    this._scrollFactorY = value;
    this.syncScrollFactor();
  }
  get cameraFilter() {
    return this._cameraFilter;
  }
  set cameraFilter(value) {
    if (this._cameraFilter === value) {
      return;
    }
    this._cameraFilter = value;
    this.syncCameraFilter();
  }
  // Compatiable with container plugin
  get list() {
    return this.children;
  }
  static GetParent(child) {
    return GetParent(child);
  }
  // For p3-container
  get parentContainer() {
    return this._parentContainer;
  }
  set parentContainer(value) {
    if (!this._parentContainer && !value) {
      this._parentContainer = value;
      return;
    }
    if (this.setParentContainerFlag) {
      this._parentContainer = value;
      return;
    }
    if (this._parentContainer && !value) {
      this.removeFromContainer();
      this._parentContainer = value;
    } else if (value) {
      this._parentContainer = value;
      this.addToContainer(value);
    } else {
      this._parentContainer = value;
    }
  }
  get setParentContainerFlag() {
    if (this._setParentContainerFlag) {
      return true;
    }
    var parent = GetParent(this);
    return parent ? parent.setParentContainerFlag : false;
  }
};
Object.assign(
  ContainerLite.prototype,
  Methods_default
);
var ContainerLite_default = ContainerLite;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/SetTransitionCallbackMethods.js
var SetTransitionCallbackMethods_default = {
  setTransitionStartCallback(callback, scope) {
    this.onStartCallback = callback;
    this.onStartCallbackScope = scope;
    return this;
  },
  setTransitionProgressCallback(callback, scope) {
    this.onProgressCallback = callback;
    this.onProgressCallbackScope = scope;
    return this;
  },
  setTransitionCompleteCallback(callback, scope) {
    this.onCompleteCallback = callback;
    this.onCompleteCallbackScope = scope;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/eventemitter/EventEmitterMethods.js
var EventEmitterMethods_default = {
  setEventEmitter(eventEmitter, EventEmitterClass) {
    if (EventEmitterClass === void 0) {
      EventEmitterClass = Phaser.Events.EventEmitter;
    }
    this._privateEE = eventEmitter === true || eventEmitter === void 0;
    this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
    return this;
  },
  destroyEventEmitter() {
    if (this._eventEmitter && this._privateEE) {
      this._eventEmitter.shutdown();
    }
    return this;
  },
  getEventEmitter() {
    return this._eventEmitter;
  },
  on() {
    if (this._eventEmitter) {
      this._eventEmitter.on.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  once() {
    if (this._eventEmitter) {
      this._eventEmitter.once.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  off() {
    if (this._eventEmitter) {
      this._eventEmitter.off.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  emit(event) {
    if (this._eventEmitter && event) {
      this._eventEmitter.emit.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  addListener() {
    if (this._eventEmitter) {
      this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeListener() {
    if (this._eventEmitter) {
      this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeAllListeners() {
    if (this._eventEmitter) {
      this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  listenerCount() {
    if (this._eventEmitter) {
      return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
    }
    return 0;
  },
  listeners() {
    if (this._eventEmitter) {
      return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
    }
    return [];
  },
  eventNames() {
    if (this._eventEmitter) {
      return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
    }
    return [];
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsSceneObject.js
var SceneClass = Phaser.Scene;
var IsSceneObject = function(object) {
  return object instanceof SceneClass;
};
var IsSceneObject_default = IsSceneObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetSceneObject.js
var GetSceneObject = function(object) {
  if (object == null || typeof object !== "object") {
    return null;
  } else if (IsSceneObject_default(object)) {
    return object;
  } else if (object.scene && IsSceneObject_default(object.scene)) {
    return object.scene;
  } else if (object.parent && object.parent.scene && IsSceneObject_default(object.parent.scene)) {
    return object.parent.scene;
  } else {
    return null;
  }
};
var GetSceneObject_default = GetSceneObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsGame.js
var GameClass = Phaser.Game;
var IsGame = function(object) {
  return object instanceof GameClass;
};
var IsGame_default = IsGame;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetGame.js
var GetGame = function(object) {
  if (object == null || typeof object !== "object") {
    return null;
  } else if (IsGame_default(object)) {
    return object;
  } else if (IsGame_default(object.game)) {
    return object.game;
  } else if (IsSceneObject_default(object)) {
    return object.sys.game;
  } else if (IsSceneObject_default(object.scene)) {
    return object.scene.sys.game;
  }
};
var GetGame_default = GetGame;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/ComponentBase.js
var GetValue5 = Phaser.Utils.Objects.GetValue;
var ComponentBase = class {
  constructor(parent, config) {
    this.setParent(parent);
    this.isShutdown = false;
    this.setEventEmitter(GetValue5(config, "eventEmitter", true));
    if (this.parent) {
      if (this.parent === this.scene) {
        this.scene.sys.events.once("shutdown", this.onEnvDestroy, this);
      } else if (this.parent === this.game) {
        this.game.events.once("shutdown", this.onEnvDestroy, this);
      } else if (this.parent.once) {
        this.parent.once("destroy", this.onParentDestroy, this);
      }
    }
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    if (this.parent) {
      if (this.parent === this.scene) {
        this.scene.sys.events.off("shutdown", this.onEnvDestroy, this);
      } else if (this.parent === this.game) {
        this.game.events.off("shutdown", this.onEnvDestroy, this);
      } else if (this.parent.once) {
        this.parent.off("destroy", this.onParentDestroy, this);
      }
    }
    this.destroyEventEmitter();
    this.parent = void 0;
    this.scene = void 0;
    this.game = void 0;
    this.isShutdown = true;
  }
  destroy(fromScene) {
    this.shutdown(fromScene);
  }
  onEnvDestroy() {
    this.destroy(true);
  }
  onParentDestroy(parent, fromScene) {
    this.destroy(fromScene);
  }
  setParent(parent) {
    this.parent = parent;
    this.scene = GetSceneObject_default(parent);
    this.game = GetGame_default(parent);
    return this;
  }
};
Object.assign(
  ComponentBase.prototype,
  EventEmitterMethods_default
);
var ComponentBase_default = ComponentBase;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/TickTask.js
var GetValue6 = Phaser.Utils.Objects.GetValue;
var TickTask = class extends ComponentBase_default {
  constructor(parent, config) {
    super(parent, config);
    this._isRunning = false;
    this.isPaused = false;
    this.tickingState = false;
    this.setTickingMode(GetValue6(config, "tickingMode", 1));
  }
  // override
  boot() {
    if (this.tickingMode === 2 && !this.tickingState) {
      this.startTicking();
    }
  }
  // override
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.stop();
    if (this.tickingState) {
      this.stopTicking();
    }
    super.shutdown(fromScene);
  }
  setTickingMode(mode) {
    if (typeof mode === "string") {
      mode = TICKINGMODE[mode];
    }
    this.tickingMode = mode;
  }
  // override
  startTicking() {
    this.tickingState = true;
  }
  // override
  stopTicking() {
    this.tickingState = false;
  }
  get isRunning() {
    return this._isRunning;
  }
  set isRunning(value) {
    if (this._isRunning === value) {
      return;
    }
    this._isRunning = value;
    if (this.tickingMode === 1 && value != this.tickingState) {
      if (value) {
        this.startTicking();
      } else {
        this.stopTicking();
      }
    }
  }
  start() {
    this.isPaused = false;
    this.isRunning = true;
    return this;
  }
  pause() {
    if (this.isRunning) {
      this.isPaused = true;
      this.isRunning = false;
    }
    return this;
  }
  resume() {
    if (this.isPaused) {
      this.isPaused = false;
      this.isRunning = true;
    }
    return this;
  }
  stop() {
    this.isPaused = false;
    this.isRunning = false;
    return this;
  }
  complete() {
    this.isPaused = false;
    this.isRunning = false;
    this.emit("complete", this.parent, this);
  }
};
var TICKINGMODE = {
  "no": 0,
  "lazy": 1,
  "always": 2
};
var TickTask_default = TickTask;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/SceneUpdateTickTask.js
var GetValue7 = Phaser.Utils.Objects.GetValue;
var SceneUpdateTickTask = class extends TickTask_default {
  constructor(parent, config) {
    super(parent, config);
    var defaultEventName = this.scene ? "update" : "step";
    this.tickEventName = GetValue7(config, "tickEventName", defaultEventName);
    this.isSceneTicker = !IsGameUpdateEvent(this.tickEventName);
  }
  startTicking() {
    super.startTicking();
    if (this.isSceneTicker) {
      this.scene.sys.events.on(this.tickEventName, this.update, this);
    } else {
      this.game.events.on(this.tickEventName, this.update, this);
    }
  }
  stopTicking() {
    super.stopTicking();
    if (this.isSceneTicker && this.scene) {
      this.scene.sys.events.off(this.tickEventName, this.update, this);
    } else if (this.game) {
      this.game.events.off(this.tickEventName, this.update, this);
    }
  }
  // update(time, delta) {
  //     
  // }
};
var IsGameUpdateEvent = function(eventName) {
  return eventName === "step" || eventName === "poststep";
};
var SceneUpdateTickTask_default = SceneUpdateTickTask;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/timerticktask/Timer.js
var GetValue8 = Phaser.Utils.Objects.GetValue;
var Clamp = Phaser.Math.Clamp;
var Timer = class {
  constructor(config) {
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.state = GetValue8(o, "state", IDLE);
    this.timeScale = GetValue8(o, "timeScale", 1);
    this.delay = GetValue8(o, "delay", 0);
    this.repeat = GetValue8(o, "repeat", 0);
    this.repeatCounter = GetValue8(o, "repeatCounter", 0);
    this.repeatDelay = GetValue8(o, "repeatDelay", 0);
    this.duration = GetValue8(o, "duration", 0);
    this.nowTime = GetValue8(o, "nowTime", 0);
    this.justRestart = GetValue8(o, "justRestart", false);
  }
  toJSON() {
    return {
      state: this.state,
      timeScale: this.timeScale,
      delay: this.delay,
      repeat: this.repeat,
      repeatCounter: this.repeatCounter,
      repeatDelay: this.repeatDelay,
      duration: this.duration,
      nowTime: this.nowTime,
      justRestart: this.justRestart
    };
  }
  destroy() {
  }
  setTimeScale(timeScale) {
    this.timeScale = timeScale;
    return this;
  }
  setDelay(delay) {
    if (delay === void 0) {
      delay = 0;
    }
    this.delay = delay;
    return this;
  }
  setDuration(duration) {
    this.duration = duration;
    return this;
  }
  setRepeat(repeat) {
    this.repeat = repeat;
    return this;
  }
  setRepeatInfinity() {
    this.repeat = -1;
    return this;
  }
  setRepeatDelay(repeatDelay) {
    this.repeatDelay = repeatDelay;
    return this;
  }
  start() {
    this.nowTime = this.delay > 0 ? -this.delay : 0;
    this.state = this.nowTime >= 0 ? COUNTDOWN : DELAY;
    this.repeatCounter = 0;
    return this;
  }
  stop() {
    this.state = IDLE;
    return this;
  }
  update(time, delta) {
    if (this.state === IDLE || this.state === DONE || delta === 0 || this.timeScale === 0) {
      return;
    }
    this.nowTime += delta * this.timeScale;
    this.justRestart = false;
    if (this.nowTime >= this.duration) {
      if (this.repeat === -1 || this.repeatCounter < this.repeat) {
        this.repeatCounter++;
        this.justRestart = true;
        this.nowTime -= this.duration;
        if (this.repeatDelay > 0) {
          this.nowTime -= this.repeatDelay;
          this.state = REPEATDELAY;
        }
      } else {
        this.nowTime = this.duration;
        this.state = DONE;
      }
    } else if (this.nowTime >= 0) {
      this.state = COUNTDOWN;
    }
  }
  get t() {
    var t;
    switch (this.state) {
      case IDLE:
      case DELAY:
      case REPEATDELAY:
        t = 0;
        break;
      case COUNTDOWN:
        t = this.nowTime / this.duration;
        break;
      case DONE:
        t = 1;
        break;
    }
    return Clamp(t, 0, 1);
  }
  set t(value) {
    value = Clamp(value, -1, 1);
    if (value < 0) {
      this.state = DELAY;
      this.nowTime = -this.delay * value;
    } else {
      this.state = COUNTDOWN;
      this.nowTime = this.duration * value;
      if (value === 1 && this.repeat !== 0) {
        this.repeatCounter++;
      }
    }
  }
  setT(t) {
    this.t = t;
    return this;
  }
  get isIdle() {
    return this.state === IDLE;
  }
  get isDelay() {
    return this.state === DELAY;
  }
  get isCountDown() {
    return this.state === COUNTDOWN;
  }
  get isRunning() {
    return this.state === DELAY || this.state === COUNTDOWN;
  }
  get isDone() {
    return this.state === DONE;
  }
  get isOddIteration() {
    return (this.repeatCounter & 1) === 1;
  }
  get isEvenIteration() {
    return (this.repeatCounter & 1) === 0;
  }
};
var IDLE = 0;
var DELAY = 1;
var COUNTDOWN = 2;
var REPEATDELAY = 3;
var DONE = -1;
var Timer_default = Timer;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/timerticktask/TimerTask.js
var TimerTickTask = class extends SceneUpdateTickTask_default {
  constructor(parent, config) {
    super(parent, config);
    this.timer = new Timer_default();
  }
  // override
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    super.shutdown(fromScene);
    this.timer.destroy();
    this.timer = void 0;
  }
  start() {
    this.timer.start();
    super.start();
    return this;
  }
  stop() {
    this.timer.stop();
    super.stop();
    return this;
  }
  complete() {
    this.timer.stop();
    super.complete();
    return this;
  }
};
var TimerTask_default = TimerTickTask;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/tweentask/EaseValueTaskBase.js
var GetValue9 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
var GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;
var EaseValueTaskBase = class extends TimerTask_default {
  resetFromJSON(o) {
    this.timer.resetFromJSON(GetValue9(o, "timer"));
    this.setEnable(GetValue9(o, "enable", true));
    this.setTarget(GetValue9(o, "target", this.parent));
    this.setDelay(GetAdvancedValue(o, "delay", 0));
    this.setDuration(GetAdvancedValue(o, "duration", 1e3));
    this.setEase(GetValue9(o, "ease", "Linear"));
    this.setRepeat(GetValue9(o, "repeat", 0));
    return this;
  }
  setEnable(e) {
    if (e == void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  setTarget(target) {
    if (target === void 0) {
      target = this.parent;
    }
    this.target = target;
    return this;
  }
  setDelay(time) {
    this.delay = time;
    return this;
  }
  setDuration(time) {
    this.duration = time;
    return this;
  }
  setRepeat(repeat) {
    this.repeat = repeat;
    return this;
  }
  setRepeatDelay(repeatDelay) {
    this.repeatDelay = repeatDelay;
    return this;
  }
  setEase(ease) {
    if (ease === void 0) {
      ease = "Linear";
    }
    this.ease = ease;
    this.easeFn = GetEaseFunction(ease);
    return this;
  }
  // Override
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    super.start();
    return this;
  }
  restart() {
    this.timer.stop();
    this.start.apply(this, arguments);
    return this;
  }
  stop(toEnd) {
    if (toEnd === void 0) {
      toEnd = false;
    }
    super.stop();
    if (toEnd) {
      this.timer.setT(1);
      this.updateTarget(this.target, this.timer);
      this.complete();
    }
    return this;
  }
  update(time, delta) {
    if (!this.isRunning || !this.enable || this.parent.hasOwnProperty("active") && !this.parent.active) {
      return this;
    }
    var target = this.target, timer = this.timer;
    timer.update(time, delta);
    if (!timer.isDelay) {
      this.updateTarget(target, timer);
    }
    this.emit("update", target, this);
    if (timer.isDone) {
      this.complete();
    }
    return this;
  }
  // Override
  updateTarget(target, timer) {
  }
};
var EaseValueTaskBase_default = EaseValueTaskBase;

// node_modules/phaser3-rex-plugins/plugins/utils/ease/EaseValueTask.js
var GetValue10 = Phaser.Utils.Objects.GetValue;
var Linear = Phaser.Math.Linear;
var EaseValueTask = class extends EaseValueTaskBase_default {
  constructor(gameObject, config) {
    super(gameObject, config);
    this.resetFromJSON();
    this.boot();
  }
  start(config) {
    if (this.timer.isRunning) {
      return this;
    }
    var target = this.target;
    this.propertyKey = GetValue10(config, "key", "value");
    var currentValue = target[this.propertyKey];
    this.fromValue = GetValue10(config, "from", currentValue);
    this.toValue = GetValue10(config, "to", currentValue);
    this.setEase(GetValue10(config, "ease", this.ease));
    this.setDuration(GetValue10(config, "duration", this.duration));
    this.setRepeat(GetValue10(config, "repeat", 0));
    this.setDelay(GetValue10(config, "delay", 0));
    this.setRepeatDelay(GetValue10(config, "repeatDelay", 0));
    this.timer.setDuration(this.duration).setRepeat(this.repeat).setDelay(this.delay).setRepeatDelay(this.repeatDelay);
    target[this.propertyKey] = this.fromValue;
    super.start();
    return this;
  }
  updateTarget(target, timer) {
    var t = timer.t;
    t = this.easeFn(t);
    target[this.propertyKey] = Linear(this.fromValue, this.toValue, t);
  }
};
var EaseValueTask_default = EaseValueTask;

// node_modules/phaser3-rex-plugins/plugins/utils/size/FitTo.js
var FitTo = function(source, target, fitMode, out) {
  if (fitMode === void 0) {
    fitMode = 0;
  } else {
    var fitModeType = typeof fitMode;
    if (fitModeType === "boolean") {
      out = fitMode;
      fitMode = 0;
    } else if (fitModeType === "string") {
      fitMode = FitModeMap[fitMode];
    }
  }
  if (out === void 0) {
    out = {};
  } else if (out === true) {
    out = globalSize;
  }
  var scaleX = target.width / source.width;
  var scaleY = target.height / source.height;
  var scale = !fitMode ? Math.min(scaleX, scaleY) : Math.max(scaleX, scaleY);
  out.width = source.width * scale;
  out.height = source.height * scale;
  return out;
};
var FitModeMap = {
  "fit": 0,
  "FIT": 0,
  "envelop": 1,
  "ENVELOP": 1
};
var globalSize = {};
var FitTo_default = FitTo;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/FitImages.js
var FitImages = function() {
  var scaleMode = this.scaleMode - 1;
  for (var i = 0, cnt = this.images.length; i < cnt; i++) {
    var image = this.images[i];
    var result = FitTo_default(image, this, scaleMode, true);
    var biasScale = result.width / image.width;
    this.setChildLocalScale(image, biasScale);
    image.biasScale = biasScale;
  }
};
var FitImages_default = FitImages;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/OnTextureChange.js
var OnTextureChange = function(newImage) {
  if (this.scaleMode === 0) {
    this.resize(newImage.width, newImage.height);
  } else {
    FitImages_default.call(this);
  }
};
var OnTextureChange_default = OnTextureChange;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/TransitionMethods.js
var IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
var GetValue11 = Phaser.Utils.Objects.GetValue;
var GetRandomItem = Phaser.Utils.Array.GetRandom;
var DirMode = {
  out: 0,
  in: 1
};
var GetValueFromConfigs = function(key2, defaultValue, ...configs) {
  for (var i = 0, cnt = configs.length; i < cnt; i++) {
    var config = configs[i];
    if (config && config.hasOwnProperty(key2)) {
      return config[key2];
    }
  }
  return defaultValue;
};
var TransitionMethods_default = {
  setTransitionDirection(dir) {
    if (typeof dir === "string") {
      dir = DirMode[dir];
    }
    this.dir = dir;
    return this;
  },
  setDuration(duration) {
    this.duration = duration;
    return this;
  },
  setEaseFunction(ease) {
    this.easeFunction = ease;
    return this;
  },
  setNextTexture(texture, frame) {
    this.nextImage.setTexture(texture, frame);
    OnTextureChange_default.call(this, this.nextImage);
    return this;
  },
  transit(texture, frame, mode) {
    if (this.isRunning) {
      this.ignoreCompleteEvent = true;
      this.stop();
      this.ignoreCompleteEvent = false;
    }
    if (mode !== void 0) {
      texture = {
        key: texture,
        frame,
        mode
      };
    }
    this.currentTransitionMode = void 0;
    if (IsPlainObject(texture)) {
      var config = texture;
      texture = GetValue11(config, "key", void 0);
      frame = GetValue11(config, "frame", void 0);
      mode = GetValue11(config, "mode");
      if (Array.isArray(mode)) {
        mode = GetRandomItem(mode);
      }
      var modeConfig;
      if (this.transitionModes && this.transitionModes.hasOwnProperty(mode)) {
        modeConfig = this.transitionModes[mode];
        this.currentTransitionMode = mode;
      }
      this.setDuration(GetValueFromConfigs("duration", this.duration, config, modeConfig)).setEaseFunction(GetValueFromConfigs("ease", this.easeFunction, config, modeConfig)).setTransitionDirection(GetValueFromConfigs("dir", this.dir, config, modeConfig));
      var maskGameObject = GetValueFromConfigs("mask", void 0, config, modeConfig);
      if (maskGameObject) {
        this.setMaskGameObject(maskGameObject);
      }
      this.setMaskEnable(maskGameObject === true);
      var onStart = GetValueFromConfigs("onStart", void 0, config, modeConfig);
      var onProgress = GetValueFromConfigs("onProgress", void 0, config, modeConfig);
      var onComplete = GetValueFromConfigs("onComplete", void 0, config, modeConfig);
      if (onStart !== void 0 || onProgress !== void 0 || onComplete !== void 0) {
        this.setTransitionStartCallback(
          onStart,
          GetValueFromConfigs("onStartScope", void 0, config, modeConfig)
        ).setTransitionProgressCallback(
          onProgress,
          GetValueFromConfigs("onProgressScope", void 0, config, modeConfig)
        ).setTransitionCompleteCallback(
          onComplete,
          GetValueFromConfigs("onCompleteScope", void 0, config, modeConfig)
        );
      }
    }
    this.setNextTexture(texture, frame);
    this.start();
    return this;
  },
  addTransitionMode(name, config) {
    if (this.transitionModes === void 0) {
      this.transitionModes = {};
    }
    if (IsPlainObject(name)) {
      config = name;
      name = config.name;
      delete config.name;
    }
    this.transitionModes[name] = config;
    return this;
  },
  start() {
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeValueTask.restart({
      key: "t",
      from: 0,
      to: 1,
      duration: this.duration,
      ease: this.easeFunction
    });
    return this;
  },
  pause() {
    if (this.easeValueTask) {
      this.easeValueTask.pause();
    }
    return this;
  },
  resume() {
    if (this.easeValueTask) {
      this.easeValueTask.resume();
    }
    return this;
  },
  stop() {
    if (this.easeValueTask) {
      this.easeValueTask.stop();
    }
    this.setT(1);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/SetPosition.js
var SetPositionBase = Phaser.GameObjects.Graphics.prototype.setPosition;
var SetPosition = function(x, y) {
  var parent = this.parent;
  if (x === void 0) {
    x = parent.x;
  }
  if (y === void 0) {
    y = parent.y;
  }
  SetPositionBase.call(this, x, y);
  return this;
};
var SetPosition_default = SetPosition;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/GetGeom.js
var RectangleGeom = Phaser.Geom.Rectangle;
var CircleGemo = Phaser.Geom.Circle;
var GetGeom = function(shapeType, width, height, padding, originX, originY, out) {
  switch (shapeType) {
    case 1:
      padding = padding.left;
      var centerX = -width * (originX - 0.5);
      var centerY = -height * (originY - 0.5);
      var radius = Math.min(width, height) / 2 + padding;
      if (out === void 0 || !(out instanceof CircleGemo)) {
        out = new CircleGemo();
      }
      out.setTo(centerX, centerY, radius);
      break;
    default:
      var topLeftX = -(width * originX) - padding.left;
      var topLeftY = -(height * originY) - padding.top;
      var rectWidth = width + padding.left + padding.right;
      var rectHeight = height + padding.top + padding.bottom;
      if (out === void 0 || !(out instanceof RectangleGeom)) {
        out = new RectangleGeom();
      }
      out.setTo(topLeftX, topLeftY, rectWidth, rectHeight);
      break;
  }
  return out;
};
var GetGeom_default = GetGeom;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/DrawShape.js
var DrawShape = function(width, height, padding, originX, originY) {
  this.geom = GetGeom_default(this.shapeType, width, height, padding, originX, originY, this.geom);
  this.clear().fillStyle(16777215);
  switch (this.shapeType) {
    case 1:
      this.fillCircleShape(this.geom);
      break;
    default:
      this.fillRectShape(this.geom);
      break;
  }
};
var DrawShape_default = DrawShape;

// node_modules/phaser3-rex-plugins/plugins/utils/object/IsKeyValueEqual.js
var IsKeyValueEqual = function(objA, objB) {
  for (var key2 in objA) {
    if (!(key2 in objB)) {
      return false;
    }
    if (objA[key2] !== objB[key2]) {
      return false;
    }
  }
  for (var key2 in objB) {
    if (!(key2 in objA)) {
      return false;
    }
  }
  return true;
};
var IsKeyValueEqual_default = IsKeyValueEqual;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/Resize.js
var Resize = function(width, height, padding) {
  var parent = this.parent;
  if (width === void 0) {
    width = parent.width;
  }
  if (height === void 0) {
    height = parent.height;
  }
  if (padding === void 0) {
    padding = this.padding;
  } else if (typeof padding === "number") {
    padding = GetBoundsConfig(padding);
  }
  var isSizeChanged = this.width !== width || this.height !== height;
  var isPaddingChanged = this.padding !== padding && !IsKeyValueEqual_default(this.padding, padding);
  if (!isSizeChanged && !isPaddingChanged) {
    return this;
  }
  this.width = width;
  this.height = height;
  if (isPaddingChanged) {
    Clone_default(padding, this.padding);
  }
  this.originX = parent.originX;
  this.originY = parent.originY;
  DrawShape_default.call(
    this,
    width,
    height,
    padding,
    parent.originX,
    parent.originY
  );
  return this;
};
var Resize_default = Resize;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/SetOrigin.js
var SetOrigin = function(originX, originY) {
  if (originY === void 0) {
    originY = originX;
  }
  var parent = this.parent;
  if (originX === void 0) {
    originX = parent.originX;
  }
  if (originY === void 0) {
    originY = parent.originY;
  }
  if (this.originX === originX && this.originY === originY) {
    return this;
  }
  this.originX = originX;
  this.originY = originY;
  DrawShape_default.call(
    this,
    this.width,
    this.height,
    this.padding,
    originX,
    originY
  );
  return this;
};
var SetOrigin_default = SetOrigin;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/Contains.js
var Contains = function(x, y) {
  x -= this.x;
  y -= this.y;
  return this.geom.contains(x, y);
};
var Contains_default = Contains;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/Methods.js
var Methods = {
  setPosition: SetPosition_default,
  resize: Resize_default,
  setOrigin: SetOrigin_default,
  contains: Contains_default
};
var Methods_default2 = Methods;

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/GetBoundsConfig.js
var GetValue12 = Phaser.Utils.Objects.GetValue;
var GetBoundsConfig2 = function(config, out) {
  if (config === void 0) {
    config = 0;
  }
  if (out === void 0) {
    out = {};
  }
  if (typeof config === "number") {
    out.left = config;
    out.right = config;
    out.top = config;
    out.bottom = config;
  } else {
    out.left = GetValue12(config, "left", 0);
    out.right = GetValue12(config, "right", 0);
    out.top = GetValue12(config, "top", 0);
    out.bottom = GetValue12(config, "bottom", 0);
  }
  return out;
};
var GetBoundsConfig_default = GetBoundsConfig2;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/DefaultMaskGraphics.js
var Graphics = Phaser.GameObjects.Graphics;
var DefaultMaskGraphics = class extends Graphics {
  constructor(parent, shapeType, padding) {
    if (shapeType === void 0) {
      shapeType = 0;
    }
    if (typeof shapeType === "string") {
      shapeType = SHAPEMODE[shapeType];
    }
    super(parent.scene);
    this.parent = parent;
    this.shapeType = shapeType;
    this.padding = GetBoundsConfig_default(padding);
    this.setPosition().resize().setVisible(false);
  }
  destroy() {
    this.parent = void 0;
    super.destroy();
    return this;
  }
};
var SHAPEMODE = {
  rectangle: 0,
  circle: 1
};
Object.assign(
  DefaultMaskGraphics.prototype,
  Methods_default2
);
var DefaultMaskGraphics_default = DefaultMaskGraphics;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/MaskMethods.js
var MaskMethods_default = {
  setMaskGameObject(gameObject) {
    if (!gameObject) {
      this.removeMaskGameObject();
      return this;
    }
    if (this.maskGameObject) {
      if (gameObject === true && this.maskGameObject instanceof DefaultMaskGraphics_default) {
        return this;
      }
      if (this.maskGameObject === gameObject) {
        return this;
      }
      this.removeMaskGameObject();
    }
    if (gameObject === true) {
      gameObject = new DefaultMaskGraphics_default(this);
    }
    gameObject.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(false);
    this.addLocal(gameObject);
    this.maskGameObject = gameObject;
    if (!gameObject._maskObject) {
      gameObject._maskObject = gameObject.createGeometryMask();
      gameObject.once("destroy", function() {
        gameObject._maskObject.destroy();
        gameObject._maskObject = void 0;
      });
    }
    this.childrenMask = gameObject._maskObject;
    return this;
  },
  removeMaskGameObject(destroyMaskGameObject) {
    if (destroyMaskGameObject === void 0) {
      destroyMaskGameObject = true;
    }
    this.backImage.clearMask();
    this.frontImage.clearMask();
    this.childrenMask = void 0;
    this.remove(this.maskGameObject, destroyMaskGameObject);
    this.maskGameObject = void 0;
    return this;
  },
  setImageMaskEnable(gameObject, enable, invertAlpha) {
    if (enable === void 0) {
      enable = true;
    }
    if (invertAlpha === void 0) {
      invertAlpha = false;
    }
    if (enable) {
      if (!this.childrenMask) {
        this.setMaskGameObject(true);
      }
      gameObject.setMask(this.childrenMask);
      this.childrenMask.setInvertAlpha(invertAlpha);
    } else {
      gameObject.clearMask();
    }
    return this;
  },
  setCurrentImageMaskEnable(enable, invertAlpha) {
    this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
    return this;
  },
  setNextImageMaskEnable(enable, invertAlpha) {
    this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
    return this;
  },
  setCellImagesMaskEnable(enable, invertAlpha) {
    var cellImages = this.getCellImages();
    for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
      this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
    }
    return this;
  },
  setMaskEnable(enable, invertAlpha) {
    this.setImageMaskEnable(this.backImage, enable, invertAlpha);
    this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
    this.setCellImagesMaskEnable(enable, invertAlpha);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/texture/gridcut/GetFrameNameCallback.js
var GetFrameNameCallback = function(baseFrameName, delimiter) {
  if (typeof baseFrameName === "object") {
    baseFrameName = baseFrameName.name;
  }
  if (delimiter === void 0) {
    delimiter = ",";
  }
  var callback;
  if (baseFrameName === "__BASE") {
    callback = function(colIndex, rowIndex) {
      return `${colIndex}${delimiter}${rowIndex}`;
    };
  } else {
    callback = function(colIndex, rowIndex) {
      return `${baseFrameName}_${colIndex}${delimiter}${rowIndex}`;
    };
  }
  return callback;
};
var GetFrameNameCallback_default = GetFrameNameCallback;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/gridcut/GenerateFrames.js
var GenerateFrames = function(scene, key2, frame, columns, rows, getFrameNameCallback) {
  if (frame == null) {
    frame = "__BASE";
  }
  if (!getFrameNameCallback) {
    getFrameNameCallback = GetFrameNameCallback_default(frame, getFrameNameCallback);
  }
  var texture = scene.sys.textures.get(key2);
  var baseFrame = typeof frame === "object" ? frame : texture.get(frame);
  var baseWidth = baseFrame.width, baseHeight = baseFrame.height;
  var cellX, cellY, cellName;
  var cellWidth = baseWidth / columns, cellHeight = baseHeight / rows;
  var frameCutX = baseFrame.cutX, frameCutY = baseFrame.cutY;
  var offsetX = 0, offsetY = 0;
  for (var y = 0; y < rows; y++) {
    offsetX = 0;
    for (var x = 0; x < columns; x++) {
      cellName = getFrameNameCallback(x, y);
      cellX = offsetX + frameCutX;
      cellY = offsetY + frameCutY;
      texture.add(
        cellName,
        0,
        cellX,
        cellY,
        cellWidth,
        cellHeight
      );
      offsetX += cellWidth;
    }
    offsetY += cellHeight;
  }
  return {
    getFrameNameCallback,
    cellWidth,
    cellHeight,
    columns,
    rows
  };
};
var GenerateFrames_default = GenerateFrames;

// node_modules/phaser3-rex-plugins/plugins/actions/GridCutImage.js
var GetValue13 = Phaser.Utils.Objects.GetValue;
var DefaultImageClass = Phaser.GameObjects.Image;
var IsPlainObject2 = Phaser.Utils.Objects.IsPlainObject;
var RotateAround3 = Phaser.Math.RotateAround;
var GridCutImage = function(gameObject, columns, rows, config) {
  if (IsPlainObject2(columns)) {
    config = columns;
    columns = GetValue13(config, "columns", 1);
    rows = GetValue13(config, "rows", 1);
  }
  var createImageCallback = GetValue13(config, "createImageCallback");
  if (!createImageCallback) {
    var ImageClass = GetValue13(config, "ImageClass", DefaultImageClass);
    createImageCallback = function(scene2, key2, frame2) {
      return new ImageClass(scene2, 0, 0, key2, frame2);
    };
  }
  var originX = GetValue13(config, "originX", 0.5);
  var originY = GetValue13(config, "originY", 0.5);
  var addToScene = GetValue13(config, "add", true);
  var align = GetValue13(config, "align", addToScene);
  var imageObjectPool = GetValue13(config, "objectPool", void 0);
  var scene = gameObject.scene;
  var texture = gameObject.texture;
  var frame = gameObject.frame;
  var result = GenerateFrames_default(scene, texture, frame, columns, rows);
  var getFrameNameCallback = result.getFrameNameCallback;
  var scaleX = gameObject.scaleX, scaleY = gameObject.scaleY;
  var rotation = gameObject.rotation;
  var topLeft = gameObject.getTopLeft(), startX = topLeft.x, startY = topLeft.y;
  var cellGameObjects = [];
  var scaleCellWidth = result.cellWidth * scaleX, scaleCellHeight = result.cellHeight * scaleY;
  for (var y = 0; y < rows; y++) {
    for (var x = 0; x < columns; x++) {
      var cellGameObject;
      var frameName = getFrameNameCallback(x, y);
      if (imageObjectPool && imageObjectPool.length > 0) {
        cellGameObject = imageObjectPool.pop().setTexture(texture, frameName);
      } else {
        cellGameObject = createImageCallback(scene, texture, frameName);
      }
      if (addToScene) {
        scene.add.existing(cellGameObject);
      }
      if (align) {
        var cellTLX = startX + scaleCellWidth * x;
        var cellTLY = startY + scaleCellHeight * y;
        var cellX = cellTLX + originX * scaleCellWidth;
        var cellY = cellTLY + originY * scaleCellHeight;
        cellGameObject.setOrigin(originX, originY).setPosition(cellX, cellY).setScale(scaleX, scaleY).setRotation(rotation);
        RotateAround3(cellGameObject, startX, startY, rotation);
      }
      cellGameObjects.push(cellGameObject);
    }
  }
  return cellGameObjects;
};
var GridCutImage_default = GridCutImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/GridCutMethods.js
var GridCutMethods_default = {
  gridCutImage(gameObject, columns, rows, config) {
    if (config === void 0) {
      config = {};
    }
    config.objectPool = this.imagesPool;
    var cellImages = GridCutImage_default(gameObject, columns, rows, config), cellImage;
    for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
      cellImage = cellImages[i];
      cellImage.setVisible(true);
      this.add(cellImage);
    }
    this.cellImages = cellImages;
    this.setChildLocalVisible(gameObject, false);
    return cellImages;
  },
  gridCutCurrentImage(columns, rows, config) {
    return this.gridCutImage(this.currentImage, columns, rows, config);
  },
  gridCutNextImage(columns, rows, config) {
    return this.gridCutImage(this.nextImage, columns, rows, config);
  },
  getCellImages() {
    return this.cellImages;
  },
  freeCellImages() {
    if (this.cellImages.length === 0) {
      return this;
    }
    var texture = this.cellImages[0].texture;
    var cellImages = this.cellImages, cellImage, frameName;
    for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
      cellImage = cellImages[i];
      this.setChildLocalAlpha(cellImage, 1).setChildLocalScale(cellImage, 1).setChildLocalVisible(cellImage, false);
      cellImage.clearMask();
      frameName = cellImage.frame.name;
      cellImage.setTexture();
      texture.remove(frameName);
    }
    this.imagesPool.push(...cellImages);
    cellImages.length = 0;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/utils/FlipMethods.js
var FlipMethods_default = {
  setFlipX(value) {
    this.flipX = value;
    return this;
  },
  setFlipY(value) {
    this.flipY = value;
    return this;
  },
  toggleFlipX() {
    this.flipX = !this.flipX;
    return this;
  },
  toggleFlipY() {
    this.flipY = !this.flipY;
    return this;
  },
  setFlip(x, y) {
    this.flipX = x;
    this.flipY = y;
    return this;
  },
  resetFlip() {
    this.flipX = false;
    this.flipY = false;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/Methods.js
var methods2 = {};
Object.assign(
  methods2,
  SetTransitionCallbackMethods_default,
  TransitionMethods_default,
  MaskMethods_default,
  GridCutMethods_default,
  FlipMethods_default
);
var Methods_default3 = methods2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/CrossFadeTransition.js
var OnStart = function(parent, currentImage, nextImage, t) {
};
var OnProgress = function(parent, currentImage, nextImage, t) {
  parent.setChildLocalAlpha(currentImage, 1 - t).setChildLocalAlpha(nextImage, t);
};
var OnComplete = function(parent, currentImage, nextImage, t) {
  parent.setChildLocalAlpha(currentImage, 1);
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/TransitionImage.js
var IsPlainObject3 = Phaser.Utils.Objects.IsPlainObject;
var GetValue14 = Phaser.Utils.Objects.GetValue;
var Clamp2 = Phaser.Math.Clamp;
var TransitionImage = class extends ContainerLite_default {
  constructor(scene, x, y, texture, frame, config) {
    if (IsPlainObject3(x)) {
      config = x;
      x = GetValue14(config, "x", 0);
      y = GetValue14(config, "y", 0);
      texture = GetValue14(config, "key", void 0);
      frame = GetValue14(config, "frame", void 0);
    } else if (IsPlainObject3(frame)) {
      config = frame;
      frame = void 0;
    }
    var backImage = GetValue14(config, "back", void 0);
    var frontImage = GetValue14(config, "front", void 0);
    if (!backImage) {
      backImage = scene.add.image(x, y, texture, frame);
    }
    if (!frontImage) {
      frontImage = scene.add.image(x, y, texture, frame);
    }
    var width = GetValue14(config, "width", void 0);
    var height = GetValue14(config, "height", void 0);
    var scaleMode = width !== void 0 && height !== void 0 ? 1 : 0;
    if (width === void 0) {
      width = frontImage.width;
    }
    if (height === void 0) {
      height = frontImage.height;
    }
    super(scene, x, y, width, height);
    this.type = "rexTransitionImage";
    this._flipX = false;
    this._flipY = false;
    scaleMode = GetValue14(config, "scaleMode", scaleMode);
    if (typeof scaleMode === "string") {
      scaleMode = ScaleModeMap[scaleMode];
    }
    this.scaleMode = scaleMode;
    backImage.setVisible(false);
    this.addMultiple([backImage, frontImage]);
    this.backImage = backImage;
    this.frontImage = frontImage;
    this.images = [this.backImage, this.frontImage];
    this.maskGameObject = void 0;
    this.cellImages = [];
    this.imagesPool = [];
    this.transitionModes = void 0;
    this.currentTransitionMode = void 0;
    var onStart = GetValue14(config, "onStart", void 0);
    var onProgress = GetValue14(config, "onProgress", void 0);
    var onComplete = GetValue14(config, "onComplete", void 0);
    var dir = GetValue14(config, "dir", 0);
    if (onStart === void 0 && onProgress === void 0 && onComplete === void 0) {
      onStart = OnStart;
      onProgress = OnProgress;
      onComplete = OnComplete;
      dir = 0;
    }
    this.setTransitionStartCallback(
      onStart,
      GetValue14(config, "onStartScope", void 0)
    ).setTransitionProgressCallback(
      onProgress,
      GetValue14(config, "onProgressScope", void 0)
    ).setTransitionCompleteCallback(
      onComplete,
      GetValue14(config, "onCompleteScope", void 0)
    ).setTransitionDirection(dir).setDuration(GetValue14(config, "duration", 1e3)).setEaseFunction(GetValue14(config, "ease", "Linear"));
    var maskGameObject = GetValue14(config, "mask", void 0);
    if (maskGameObject) {
      this.setMaskGameObject(maskGameObject);
    }
    this.setMaskEnable(false);
    this.ignoreCompleteEvent = false;
    OnTextureChange_default.call(this, this.frontImage);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (this.childrenMask) {
      this.childrenMask.destroy();
      this.childrenMask = void 0;
    }
    this.backImage = void 0;
    this.frontImage = void 0;
    this.images.length = 0;
    this.maskGameObject = void 0;
    this.cellImages.length = 0;
    this.imagesPool.length = 0;
    this.transitionModes = void 0;
    super.destroy(fromScene);
    this.onStartCallback = void 0;
    this.onStartCallbackScope = void 0;
    this.onProgressCallback = void 0;
    this.onProgressCallbackScope = void 0;
    this.onCompleteCallback = void 0;
    this.onCompleteCallbackScope = void 0;
    this.easeValueTask = void 0;
  }
  get currentImage() {
    return this.dir === 0 ? this.frontImage : this.backImage;
  }
  get nextImage() {
    return this.dir === 0 ? this.backImage : this.frontImage;
  }
  get texture() {
    return this.nextImage.texture;
  }
  get frame() {
    return this.nextImage.frame;
  }
  get tint() {
    return this._tint;
  }
  set tint(value) {
    if (this._tint === value) {
      return;
    }
    this._tint = value;
    this.backImage.setTint(value);
    this.frontImage.setTint(value);
  }
  setTint(value) {
    this.tint = value;
    return this;
  }
  get flipX() {
    return this._flipX;
  }
  set flipX(value) {
    if (this._flipX === value) {
      return;
    }
    this._flipX = value;
    this.backImage.setFlipX(value);
    this.frontImage.setFlipX(value);
  }
  setFlipX(value) {
    this.flipX = value;
    return this;
  }
  toggleFlipX() {
    this.flipX = !this.flipX;
    return this;
  }
  get flipY() {
    return this._flipY;
  }
  set flipY(value) {
    if (this._flipY === value) {
      return;
    }
    this._flipY = value;
    this.backImage.setFlipY(value);
    this.frontImage.setFlipY(value);
  }
  setFlipY(value) {
    this.flipY = value;
    return this;
  }
  toggleFlipY() {
    this.flipY = !this.flipY;
    return this;
  }
  setFlip(flipX, flipY) {
    this.flipX = flipX;
    this.flipY = flipY;
    return this;
  }
  get t() {
    return this._t;
  }
  set t(value) {
    value = Clamp2(value, 0, 1);
    if (this._t === value) {
      return;
    }
    this._t = value;
    var currentImage = this.currentImage;
    var nextImage = this.nextImage;
    if (value === 0) {
      this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, true);
      RunCallback.call(
        this,
        this.onStartCallback,
        this.onStartCallbackScope,
        this,
        currentImage,
        nextImage,
        value
      );
    }
    RunCallback.call(
      this,
      this.onProgressCallback,
      this.onProgressCallbackScope,
      this,
      currentImage,
      nextImage,
      value
    );
    if (value === 1) {
      RunCallback.call(
        this,
        this.onCompleteCallback,
        this.onCompleteCallbackScope,
        this,
        currentImage,
        nextImage,
        value
      );
      var key2 = nextImage.texture.key, frame = nextImage.frame.name;
      this.frontImage.setTexture(key2, frame);
      this.backImage.setTexture(key2, frame);
      OnTextureChange_default.call(this, nextImage);
      this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, false).setMaskEnable(false).freeCellImages();
    }
    if (value === 1 && !this.ignoreCompleteEvent) {
      this.emit("complete");
    }
  }
  setT(value) {
    this.t = value;
    return this;
  }
  get isRunning() {
    return this.easeValueTask ? this.easeValueTask.isRunning : false;
  }
  setOrigin(originX, originY) {
    super.setOrigin(originX, originY);
    this.backImage.setOrigin(originX, originY);
    this.frontImage.setOrigin(originX, originY);
    if (this.maskGameObject) {
      this.maskGameObject.setOrigin(originX, originY);
    }
    return this;
  }
  setTexture(texture, frame) {
    this.frontImage.setTexture(texture, frame);
    this.backImage.setTexture(texture, frame).setVisible(false);
    OnTextureChange_default.call(this, this.frontImage);
    return this;
  }
  setSize(width, height) {
    super.setSize(width, height);
    if (this.scaleMode) {
      FitImages_default.call(this);
    }
    return this;
  }
};
var RunCallback = function(callback, scope, parent, currentImage, nextImage, t) {
  if (!callback) {
    return;
  }
  if (this.scaleMode) {
    var localScale;
    if (currentImage.biasScale > 0) {
      localScale = this.getChildLocalScaleX(currentImage);
      localScale = localScale / currentImage.biasScale;
      this.setChildLocalScale(currentImage, localScale);
    }
    if (nextImage.biasScale) {
      localScale = this.getChildLocalScaleX(nextImage);
      localScale = localScale / nextImage.biasScale;
      this.setChildLocalScale(nextImage, localScale);
    }
  }
  if (scope) {
    callback.call(scope, parent, currentImage, nextImage, t);
  } else {
    callback(parent, currentImage, nextImage, t);
  }
  if (this.scaleMode) {
    var localScale;
    if (currentImage.biasScale > 0) {
      localScale = this.getChildLocalScaleX(currentImage);
      localScale = localScale * currentImage.biasScale;
      this.setChildLocalScale(currentImage, localScale);
    }
    if (nextImage.biasScale) {
      localScale = this.getChildLocalScaleX(nextImage);
      localScale = localScale * nextImage.biasScale;
      this.setChildLocalScale(nextImage, localScale);
    }
  }
};
Object.assign(
  TransitionImage.prototype,
  Methods_default3
);
var ScaleModeMap = {
  fit: 1,
  FIT: 1,
  envelop: 2,
  ENVELOP: 2
};
var TransitionImage_default = TransitionImage;

// node_modules/phaser3-rex-plugins/plugins/transitionimage.js
var transitionimage_default = TransitionImage_default;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/Const.js
var SlideLeft = "slideLeft";
var SlideRight = "slideRight";
var SlideUp = "slideUp";
var SlideDown = "slideDown";
var SlideAwayLeft = "slideAwayLeft";
var SlideAwayRight = "slideAwayRight";
var SlideAwayUp = "slideAwayUp";
var SlideAwayDown = "slideAwayDown";
var PushLeft = "pushLeft";
var PushRight = "pushRight";
var PushUp = "pushUp";
var PushDown = "pushDown";
var ZoomOut = "zoomOut";
var ZoomIn = "zoomIn";
var ZoomInOut = "zoomInOut";
var Fade = "fade";
var CrossFade = "crossFade";
var WipeLeft = "wipeLeft";
var WipeRight = "wipeRight";
var WipeUp = "wipeUp";
var WipeDown = "wipeDown";
var IrisOut = "irisOut";
var IrisIn = "irisIn";
var IrisInOut = "irisInOut";
var PieOut = "pieOut";
var PieIn = "pieIn";
var PieInOut = "pieInOut";
var Blinds = "blinds";
var Squares = "squares";
var Diamonds = "diamonds";
var Circles = "circles";
var Curtain = "curtain";
var Pixellate = "pixellate";
var Dissolve = "dissolve";
var RevealLeft = "revealLeft";
var RevealRight = "revealRight";
var RevealUp = "revealUp";
var RevealDown = "revealDown";

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddSlideAwayModes.js
var AddSlideAwayModes = function(image) {
  image.addTransitionMode(SlideAwayRight, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * t;
      parent.setChildLocalPosition(currentImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  }).addTransitionMode(SlideAwayLeft, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * -t;
      parent.setChildLocalPosition(currentImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  }).addTransitionMode(SlideAwayDown, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * t;
      parent.setChildLocalPosition(currentImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  }).addTransitionMode(SlideAwayUp, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * -t;
      parent.setChildLocalPosition(currentImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  });
};
var AddSlideAwayModes_default = AddSlideAwayModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddSlideModes.js
var AddSlideModes = function(image) {
  image.addTransitionMode(SlideRight, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = nextImage.width * (t - 1);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(SlideLeft, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = nextImage.width * (1 - t);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(SlideDown, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = nextImage.height * (t - 1);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(SlideUp, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = nextImage.height * (1 - t);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  });
};
var AddSlideModes_default = AddSlideModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddPushModes.js
var AddSliderModes = function(image) {
  image.addTransitionMode(PushRight, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * t;
      parent.setChildLocalPosition(currentImage, x, 0);
      var x = nextImage.width * (t - 1);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(PushLeft, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * -t;
      parent.setChildLocalPosition(currentImage, x, 0);
      var x = nextImage.width * (1 - t);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(PushDown, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * t;
      parent.setChildLocalPosition(currentImage, 0, y);
      var y = nextImage.height * (t - 1);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(PushUp, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * -t;
      parent.setChildLocalPosition(currentImage, 0, y);
      var y = nextImage.height * (1 - t);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  });
};
var AddPushModes_default = AddSliderModes;

// node_modules/phaser3-rex-plugins/plugins/utils/math/Yoyo.js
var Yoyo = function(t, threshold) {
  if (threshold === void 0) {
    threshold = 0.5;
  }
  if (t <= threshold) {
    t = t / threshold;
  } else {
    t = 1 - (t - threshold) / (1 - threshold);
  }
  return t;
};
var Yoyo_default = Yoyo;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/Yoyo.js
var Yoyo_default2 = Yoyo_default;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddZoomModes.js
var AddZoomModes = function(image) {
  image.addTransitionMode(ZoomOut, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var scale = 1 - t;
      parent.setChildLocalScale(currentImage, scale, scale);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalScale(currentImage, 1, 1);
    }
  }).addTransitionMode(ZoomIn, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var scale = t;
      parent.setChildLocalScale(nextImage, scale, scale);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalScale(nextImage, 1, 1);
    }
  }).addTransitionMode(ZoomInOut, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var scale;
      if (t < 0.5) {
        scale = 1 - Yoyo_default2(t);
        parent.setChildLocalScale(currentImage, scale, scale);
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        scale = 1 - Yoyo_default2(t);
        parent.setChildLocalScale(nextImage, scale, scale);
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalScale(currentImage, 1, 1);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildLocalScale(nextImage, 1, 1);
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddZoomModes_default = AddZoomModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddFadeModes.js
var AddFadeModes = function(image) {
  image.addTransitionMode(Fade, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  }).addTransitionMode(CrossFade, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalAlpha(currentImage, 1 - t);
      parent.setChildLocalAlpha(nextImage, t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalAlpha(currentImage, 1);
    }
  });
};
var AddFadeModes_default = AddFadeModes;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/render/WebGLRenderer.js
var GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;
var WebGLRenderer = function(renderer, src, camera, parentMatrix2) {
  src.updateData();
  camera.addToRenderList(src);
  var pipeline = renderer.pipelines.set(src.pipeline);
  var result = GetCalcMatrix(src, camera, parentMatrix2);
  var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
  var dx = src._displayOriginX;
  var dy = src._displayOriginY;
  var alpha = camera.alpha * src.alpha;
  renderer.pipelines.preBatch(src);
  var shapes = src.geom, shape;
  for (var i = 0, cnt = shapes.length; i < cnt; i++) {
    shape = shapes[i];
    if (shape.visible) {
      shape.webglRender(pipeline, calcMatrix, alpha, dx, dy);
    }
  }
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default = WebGLRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/render/CanvasRenderer.js
var SetTransform = Phaser.Renderer.Canvas.SetTransform;
var CanvasRenderer = function(renderer, src, camera, parentMatrix2) {
  src.updateData();
  camera.addToRenderList(src);
  var ctx = renderer.currentContext;
  if (SetTransform(renderer, ctx, src, camera, parentMatrix2)) {
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var shapes = src.geom, shape;
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      shape = shapes[i];
      if (shape.visible) {
        shape.canvasRender(ctx, dx, dy);
      }
    }
    ctx.restore();
  }
};
var CanvasRenderer_default = CanvasRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/render/Render.js
var Render_default = {
  renderWebGL: WebGLRenderer_default,
  renderCanvas: CanvasRenderer_default
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/BaseShapes.js
var Shape = Phaser.GameObjects.Shape;
var RemoveItem2 = Phaser.Utils.Array.Remove;
var BaseShapes = class extends Shape {
  constructor(scene, x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 2;
    }
    if (height === void 0) {
      height = width;
    }
    super(scene, "rexShapes", []);
    this._width = -1;
    this._height = -1;
    this.dirty = true;
    this.isSizeChanged = true;
    this.shapes = {};
    this.setPosition(x, y);
    this.setSize(width, height);
    this.updateDisplayOrigin();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.setSize(value, this._height);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.setSize(this._width, value);
  }
  setDirty(value) {
    if (value === void 0) {
      value = true;
    }
    this.dirty = value;
    return this;
  }
  setSize(width, height) {
    this.isSizeChanged = this.isSizeChanged || this._width !== width || this._height !== height;
    this.dirty = this.dirty || this.isSizeChanged;
    this._width = width;
    this._height = height;
    this.updateDisplayOrigin();
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = width;
      input.hitArea.height = height;
    }
    return this;
  }
  resize(width, height) {
    this.setSize(width, height);
    return this;
  }
  get fillColor() {
    return this._fillColor;
  }
  set fillColor(value) {
    this.setFillStyle(value, this._fillAlpha);
  }
  get fillAlpha() {
    return this._fillAlpha;
  }
  set fillAlpha(value) {
    this.setFillStyle(this._fillColor, value);
  }
  setFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.fillColor !== color || this.fillAlpha !== alpha;
    this._fillColor = color;
    this._fillAlpha = alpha;
    return this;
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set lineWidth(value) {
    this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
  }
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(value) {
    this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
  }
  get strokeAlpha() {
    return this._strokeAlpha;
  }
  set strokeAlpha(value) {
    this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
  }
  setStrokeStyle(lineWidth, color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.lineWidth !== lineWidth || this.strokeColor !== color || this.strokeAlpha !== alpha;
    this._lineWidth = lineWidth;
    this._strokeColor = color;
    this._strokeAlpha = alpha;
    return this;
  }
  updateShapes() {
  }
  updateData() {
    if (!this.dirty) {
      return this;
    }
    this.updateShapes();
    var shapes = this.geom;
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var shape = shapes[i];
      if (shape.dirty) {
        shape.updateData();
      }
    }
    this.isSizeChanged = false;
    this.dirty = false;
    return this;
  }
  clear() {
    this.geom.length = 0;
    Clear_default(this.shapes);
    this.dirty = true;
    return this;
  }
  getShape(name) {
    return this.shapes[name];
  }
  getShapes() {
    return this.geom;
  }
  addShape(shape) {
    this.geom.push(shape);
    var name = shape.name;
    if (name) {
      this.shapes[name] = shape;
    }
    this.dirty = true;
    return this;
  }
  deleteShape(name) {
    var shape = this.getShape(name);
    if (shape) {
      delete this.shapes[name];
      RemoveItem2(this.geom, shape);
    }
    return this;
  }
};
Object.assign(
  BaseShapes.prototype,
  Render_default
);
var BaseShapes_default = BaseShapes;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/base/StyleMethods.js
var FillStyle = function(color, alpha) {
  if (color == null) {
    this.isFilled = false;
  } else {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.isFilled = true;
    this.fillColor = color;
    this.fillAlpha = alpha;
  }
  return this;
};
var LineStyle = function(lineWidth, color, alpha) {
  if (lineWidth == null || color == null) {
    this.isStroked = false;
  } else {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.isStroked = true;
    this.lineWidth = lineWidth;
    this.strokeColor = color;
    this.strokeAlpha = alpha;
  }
  return this;
};
var StyleMethods_default = {
  fillStyle: FillStyle,
  lineStyle: LineStyle
};

// node_modules/phaser3-rex-plugins/plugins/utils/object/GetValue.js
var GetValue15 = function(source, key2, defaultValue) {
  if (!source || typeof source === "number") {
    return defaultValue;
  }
  if (typeof key2 === "string") {
    if (source.hasOwnProperty(key2)) {
      return source[key2];
    }
    if (key2.indexOf(".") !== -1) {
      key2 = key2.split(".");
    } else {
      return defaultValue;
    }
  }
  var keys = key2;
  var parent = source;
  var value = defaultValue;
  for (var i = 0; i < keys.length; i++) {
    key2 = keys[i];
    if (parent.hasOwnProperty(key2)) {
      value = parent[key2];
      parent = value;
    } else {
      value = defaultValue;
      break;
    }
  }
  return value;
};
var GetValue_default = GetValue15;

// node_modules/phaser3-rex-plugins/plugins/utils/data/DataMethods.js
var DataMethods_default = {
  enableData() {
    if (this.data === void 0) {
      this.data = {};
    }
    return this;
  },
  setData(key2, value) {
    this.enableData();
    if (arguments.length === 1) {
      var data = key2;
      for (key2 in data) {
        this.data[key2] = data[key2];
      }
    } else {
      this.data[key2] = value;
    }
    return this;
  },
  getData(key2, defaultValue) {
    this.enableData();
    return key2 === void 0 ? this.data : GetValue_default(this.data, key2, defaultValue);
  },
  incData(key2, inc, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = 0;
    }
    this.enableData();
    this.setData(key2, this.getData(key2, defaultValue) + inc);
    return this;
  },
  mulData(key2, mul, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = 0;
    }
    this.enableData();
    this.setData(key2, this.getData(key2, defaultValue) * mul);
    return this;
  },
  clearData() {
    if (this.data) {
      Clear_default(this.data);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/base/BaseGeom.js
var BaseGeom = class {
  constructor() {
    this.name = void 0;
    this.dirty = true;
    this.visible = true;
    this.data = void 0;
    this.isFilled = false;
    this.fillColor = void 0;
    this.fillAlpha = 1;
    this.isStroked = false;
    this.lineWidth = 1;
    this.strokeColor = void 0;
    this.strokeAlpha = 1;
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setVisible(visible) {
    if (visible === void 0) {
      visible = true;
    }
    this.visible = visible;
    return this;
  }
  reset() {
    this.setVisible().fillStyle().lineStyle();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
  }
  canvasRender(ctx, dx, dy) {
  }
  updateData() {
    this.dirty = false;
  }
};
Object.assign(
  BaseGeom.prototype,
  StyleMethods_default,
  DataMethods_default
);
var BaseGeom_default = BaseGeom;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/FillPathWebGL.js
var Utils = Phaser.Renderer.WebGL.Utils;
var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
  var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
  var path = src.pathData;
  var pathIndexes = src.pathIndexes;
  for (var i = 0; i < pathIndexes.length; i += 3) {
    var p0 = pathIndexes[i] * 2;
    var p1 = pathIndexes[i + 1] * 2;
    var p2 = pathIndexes[i + 2] * 2;
    var x0 = path[p0 + 0] - dx;
    var y0 = path[p0 + 1] - dy;
    var x1 = path[p1 + 0] - dx;
    var y1 = path[p1 + 1] - dy;
    var x2 = path[p2 + 0] - dx;
    var y2 = path[p2 + 1] - dy;
    var tx0 = calcMatrix.getX(x0, y0);
    var ty0 = calcMatrix.getY(x0, y0);
    var tx1 = calcMatrix.getX(x1, y1);
    var ty1 = calcMatrix.getY(x1, y1);
    var tx2 = calcMatrix.getX(x2, y2);
    var ty2 = calcMatrix.getY(x2, y2);
    pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
  }
};
var FillPathWebGL_default = FillPathWebGL;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/StrokePathWebGL.js
var Utils2 = Phaser.Renderer.WebGL.Utils;
var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
  var strokeTint = pipeline.strokeTint;
  var strokeTintColor = Utils2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
  strokeTint.TL = strokeTintColor;
  strokeTint.TR = strokeTintColor;
  strokeTint.BL = strokeTintColor;
  strokeTint.BR = strokeTintColor;
  var path = src.pathData;
  var pathLength = path.length - 1;
  var lineWidth = src.lineWidth;
  var halfLineWidth = lineWidth / 2;
  var px1 = path[0] - dx;
  var py1 = path[1] - dy;
  if (!src.closePath) {
    pathLength -= 2;
  }
  for (var i = 2; i < pathLength; i += 2) {
    var px2 = path[i] - dx;
    var py2 = path[i + 1] - dy;
    pipeline.batchLine(
      px1,
      py1,
      px2,
      py2,
      halfLineWidth,
      halfLineWidth,
      lineWidth,
      i - 2,
      src.closePath ? i === pathLength - 1 : false
    );
    px1 = px2;
    py1 = py2;
  }
};
var StrokePathWebGL_default = StrokePathWebGL;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/FillStyleCanvas.js
var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
  var fillColor = altColor ? altColor : src.fillColor;
  var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
  var red = (fillColor & 16711680) >>> 16;
  var green = (fillColor & 65280) >>> 8;
  var blue = fillColor & 255;
  ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
};
var FillStyleCanvas_default = FillStyleCanvas;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/LineStyleCanvas.js
var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
  var strokeColor = altColor ? altColor : src.strokeColor;
  var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
  var red = (strokeColor & 16711680) >>> 16;
  var green = (strokeColor & 65280) >>> 8;
  var blue = strokeColor & 255;
  ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
  ctx.lineWidth = src.lineWidth;
};
var LineStyleCanvas_default = LineStyleCanvas;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/PathBase.js
var Earcut = Phaser.Geom.Polygon.Earcut;
var PathBase = class extends BaseGeom_default {
  constructor() {
    super();
    this.pathData = [];
    this.pathIndexes = [];
    this.closePath = false;
  }
  updateData() {
    this.pathIndexes = Earcut(this.pathData);
    super.updateData();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
    if (this.isFilled) {
      FillPathWebGL_default(pipeline, calcMatrix, this, alpha, dx, dy);
    }
    if (this.isStroked) {
      StrokePathWebGL_default(pipeline, this, alpha, dx, dy);
    }
  }
  canvasRender(ctx, dx, dy) {
    var path = this.pathData;
    var pathLength = path.length - 1;
    var px1 = path[0] - dx;
    var py1 = path[1] - dy;
    ctx.beginPath();
    ctx.moveTo(px1, py1);
    if (!this.closePath) {
      pathLength -= 2;
    }
    for (var i = 2; i < pathLength; i += 2) {
      var px2 = path[i] - dx;
      var py2 = path[i + 1] - dy;
      ctx.lineTo(px2, py2);
    }
    if (this.closePath) {
      ctx.closePath();
    }
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fill();
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.stroke();
    }
  }
};
var PathBase_default = PathBase;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/LineTo.js
var LineTo = function(x, y, pathData) {
  var cnt = pathData.length;
  if (cnt >= 2) {
    var lastX = pathData[cnt - 2];
    var lastY = pathData[cnt - 1];
    if (x === lastX && y === lastY) {
      return pathData;
    }
  }
  pathData.push(x, y);
  return pathData;
};
var LineTo_default = LineTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/ArcTo.js
var DegToRad3 = Phaser.Math.DegToRad;
var ArcTo = function(centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
  if (antiClockWise && endAngle > startAngle) {
    endAngle -= 360;
  } else if (!antiClockWise && endAngle < startAngle) {
    endAngle += 360;
  }
  var deltaAngle = endAngle - startAngle;
  var step = DegToRad3(deltaAngle) / iteration;
  startAngle = DegToRad3(startAngle);
  for (var i = 0; i <= iteration; i++) {
    var angle = startAngle + step * i;
    var x = centerX + radiusX * Math.cos(angle);
    var y = centerY + radiusY * Math.sin(angle);
    LineTo_default(x, y, pathData);
  }
  return pathData;
};
var ArcTo_default = ArcTo;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/arc/Arc.js
var DegToRad4 = Phaser.Math.DegToRad;
var Arc = class extends PathBase_default {
  constructor(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (radiusX === void 0) {
      radiusX = 0;
    }
    if (radiusY === void 0) {
      radiusY = 0;
    }
    if (startAngle === void 0) {
      startAngle = 0;
    }
    if (endAngle === void 0) {
      endAngle = 360;
    }
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    if (pie === void 0) {
      pie = false;
    }
    super();
    this.setCenterPosition(x, y);
    this.setRadius(radiusX, radiusY);
    this.setAngle(startAngle, endAngle, anticlockwise);
    this.setPie(pie);
    this.setIterations(32);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.dirty = this.dirty || this._x !== value;
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.dirty = this.dirty || this._y !== value;
    this._y = value;
  }
  setCenterPosition(x, y) {
    if (y === void 0) {
      y = x;
    }
    this.x = x;
    this.y = y;
    return this;
  }
  get radiusX() {
    return this._radiusX;
  }
  set radiusX(value) {
    this.dirty = this.dirty || this._radiusX !== value;
    this._radiusX = value;
  }
  get radiusY() {
    return this._radiusY;
  }
  set radiusY(value) {
    this.dirty = this.dirty || this._radiusY !== value;
    this._radiusY = value;
  }
  setRadius(radiusX, radiusY) {
    if (radiusY === void 0) {
      radiusY = radiusX;
    }
    this.radiusX = radiusX;
    this.radiusY = radiusY;
    return this;
  }
  get startAngle() {
    return this._startAngle;
  }
  set startAngle(value) {
    this.dirty = this.dirty || this._startAngle !== value;
    this._startAngle = value;
  }
  get endAngle() {
    return this._endAngle;
  }
  set endAngle(value) {
    this.dirty = this.dirty || this._endAngle !== value;
    this._endAngle = value;
  }
  get anticlockwise() {
    return this._anticlockwise;
  }
  set anticlockwise(value) {
    this.dirty = this.dirty || this._anticlockwise !== value;
    this._anticlockwise = value;
  }
  setAngle(startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.anticlockwise = anticlockwise;
    return this;
  }
  get pie() {
    return this._pie;
  }
  set pie(value) {
    this.dirty = this.dirty || this._pie !== value;
    this._pie = value;
  }
  setPie(pie) {
    if (pie === void 0) {
      pie = true;
    }
    this.pie = pie;
    return this;
  }
  get iterations() {
    return this._iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this._iterations !== value;
    this._iterations = value;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    if (this.pie) {
      this.pathData.push(this.x, this.y);
    }
    ArcTo_default(
      this.x,
      this.y,
      this.radiusX,
      this.radiusY,
      this.startAngle,
      this.endAngle,
      this.anticlockwise,
      this.iterations,
      this.pathData
    );
    if (this.pie) {
      this.pathData.push(this.x, this.y);
    }
    this.pathData.push(this.pathData[0], this.pathData[1]);
    super.updateData();
    return this;
  }
  canvasRender(ctx, dx, dy) {
    ctx.beginPath();
    var x = this.x - dx, y = this.y - dy, startAngle = DegToRad4(this.startAngle), endAngle = DegToRad4(this.endAngle);
    if (this.pie) {
      ctx.moveTo(x, y);
      ctx.lineTo(
        x + Math.cos(startAngle) * this.radiusX,
        y + Math.sin(startAngle) * this.radiusY
      );
    }
    ctx.ellipse(
      x,
      y,
      this.radiusX,
      this.radiusY,
      0,
      startAngle,
      endAngle,
      this.anticlockwise
    );
    if (this.pie) {
      ctx.lineTo(x, y);
    }
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fill();
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.stroke();
    }
  }
};
var Arc_default = Arc;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/arc/Circle.js
var Circle = class extends Arc_default {
  constructor(x, y, radius) {
    super(x, y, radius, radius, 0, 360);
  }
};
var Circle_default = Circle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/Curve.js
var Curve = class extends PathBase_default {
  constructor(curve) {
    super();
    this.setCurve(curve);
    this.setIterations(32);
  }
  get curve() {
    return this._curve;
  }
  set curve(value) {
    this.dirty = this.dirty || this._curve !== value;
    this._curve = value;
  }
  setCurve(curve) {
    this.curve = curve;
    return this;
  }
  get iterations() {
    return this._iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this._iterations !== value;
    this._iterations = value;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    var points = this.curve.getPoints(this.iterations);
    for (var i = 0, cnt = points.length; i < cnt; i++) {
      this.pathData.push(points[i].x, points[i].y);
    }
    this.pathData.push(points[0].x, points[0].y);
    super.updateData();
    return this;
  }
};
var Curve_default = Curve;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/arc/Ellipse.js
var Ellipse = class extends Arc_default {
  constructor(x, y, radiusX, radiusY) {
    super(x, y, radiusX, radiusY, 0, 360);
  }
};
var Ellipse_default = Ellipse;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/Line.js
var Line = class extends PathBase_default {
  constructor(x0, y0, x1, y1) {
    if (x0 === void 0) {
      x0 = 0;
    }
    if (y0 === void 0) {
      y0 = 0;
    }
    if (x1 === void 0) {
      x1 = 0;
    }
    if (y1 === void 0) {
      y1 = 0;
    }
    super();
    this.setP0(x0, y0);
    this.setP1(x1, y1);
  }
  get x0() {
    return this._x0;
  }
  set x0(value) {
    this.dirty = this.dirty || this._x0 !== value;
    this._x0 = value;
  }
  get y0() {
    return this._y0;
  }
  set y0(value) {
    this.dirty = this.dirty || this._y0 !== value;
    this._y0 = value;
  }
  setP0(x, y) {
    this.x0 = x;
    this.y0 = y;
    return this;
  }
  get x1() {
    return this._x1;
  }
  set x1(value) {
    this.dirty = this.dirty || this._x1 !== value;
    this._x1 = value;
  }
  get y1() {
    return this._y1;
  }
  set y1(value) {
    this.dirty = this.dirty || this._y1 !== value;
    this._y1 = value;
  }
  setP1(x, y) {
    this.x1 = x;
    this.y1 = y;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    this.pathData.push(this.x0, this.y0);
    this.pathData.push(this.x1, this.y1);
    this.pathData.push(this.x0, this.y0);
    super.updateData();
    return this;
  }
};
var Line_default = Line;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/StartAt.js
var StartAt = function(x, y, pathData) {
  pathData.length = 0;
  if (x != null) {
    pathData.push(x, y);
  }
  return pathData;
};
var StartAt_default = StartAt;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/QuadraticBezierTo.js
var QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;
var QuadraticBezierTo = function(cx, cy, x, y, iterations, pathData) {
  var pathDataCnt2 = pathData.length;
  var p0x = pathData[pathDataCnt2 - 2];
  var p0y = pathData[pathDataCnt2 - 1];
  for (var i = 1, last = iterations - 1; i <= last; i++) {
    var t = i / last;
    pathData.push(
      QuadraticBezierInterpolation(t, p0x, cx, x),
      QuadraticBezierInterpolation(t, p0y, cy, y)
    );
  }
  return pathData;
};
var QuadraticBezierTo_default = QuadraticBezierTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/CubicBezierCurveTo.js
var CubicBezierInterpolation = Phaser.Math.Interpolation.CubicBezier;
var CubicBezierCurveTo = function(cx0, cy0, cx1, cy1, x, y, iterations, pathData) {
  var pathDataCnt2 = pathData.length;
  var p0x = pathData[pathDataCnt2 - 2];
  var p0y = pathData[pathDataCnt2 - 1];
  for (var i = 1, last = iterations - 1; i <= last; i++) {
    var t = i / last;
    pathData.push(
      CubicBezierInterpolation(t, p0x, cx0, cx1, x),
      CubicBezierInterpolation(t, p0y, cy0, cy1, y)
    );
  }
  return pathData;
};
var CubicBezierCurveTo_default = CubicBezierCurveTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/CatmullRomTo.js
var CatmullRomInterpolation = Phaser.Math.Interpolation.CatmullRom;
var CatmullRomTo = function(points, iterations, pathData) {
  var pathDataCnt2 = pathData.length;
  var p0x = pathData[pathDataCnt2 - 2];
  var p0y = pathData[pathDataCnt2 - 1];
  var xList = [p0x];
  var yList = [p0y];
  for (var i = 0, cnt = points.length; i < cnt; i += 2) {
    xList.push(points[i]);
    yList.push(points[i + 1]);
  }
  for (var i = 1, last = iterations - 1; i <= last; i++) {
    var t = i / last;
    pathData.push(
      CatmullRomInterpolation(xList, t),
      CatmullRomInterpolation(yList, t)
    );
  }
  return pathData;
};
var CatmullRomTo_default = CatmullRomTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/DuplicateLast.js
var DuplicateLast = function(pathData) {
  var len = pathData.length;
  if (len < 2) {
    return pathData;
  }
  var lastX = pathData[len - 2];
  var lastY = pathData[len - 1];
  pathData.push(lastX);
  pathData.push(lastY);
  return pathData;
};
var DuplicateLast_default = DuplicateLast;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/AddPathMethods.js
var AddPathMethods_default = {
  clear() {
    this.start();
    return this;
  },
  start() {
    this.startAt();
    return this;
  },
  startAt(x, y) {
    this.restorePathData();
    this.accumulationLengths = void 0;
    StartAt_default(x, y, this.pathData);
    this.firstPointX = x;
    this.firstPointY = y;
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  lineTo(x, y, relative) {
    if (relative === void 0) {
      relative = false;
    }
    if (relative) {
      x += this.lastPointX;
      y += this.lastPointY;
    }
    LineTo_default(x, y, this.pathData);
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  verticalLineTo(x, relative) {
    this.lineTo(x, this.lastPointY, relative);
    return this;
  },
  horizontalLineTo(y, relative) {
    this.lineTo(this.lastPointX, y, relative);
    return this;
  },
  ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    ArcTo_default(
      centerX,
      centerY,
      radiusX,
      radiusY,
      startAngle,
      endAngle,
      anticlockwise,
      this.iterations,
      this.pathData
    );
    this.lastPointX = this.pathData[this.pathData.length - 2];
    this.lastPointY = this.pathData[this.pathData.length - 1];
    return this;
  },
  arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
    this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
    return this;
  },
  quadraticBezierTo(cx, cy, x, y) {
    QuadraticBezierTo_default(
      cx,
      cy,
      x,
      y,
      this.iterations,
      this.pathData
    );
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
    CubicBezierCurveTo_default(
      cx0,
      cy0,
      cx1,
      cy1,
      x,
      y,
      this.iterations,
      this.pathData
    );
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  catmullRomTo(...points) {
    CatmullRomTo_default(
      points,
      this.iterations,
      this.pathData
    );
    this.lastPointX = points[points.length - 2];
    this.lastPointY = points[points.length - 1];
    return this;
  },
  close() {
    var startX = this.pathData[0], startY = this.pathData[1];
    if (startX !== this.lastPointX || startY !== this.lastPointY) {
      this.lineTo(startX, startY);
    }
    this.closePath = true;
    return this;
  },
  end() {
    DuplicateLast_default(this.pathData);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/RotateAround.js
var PointRotateAround = Phaser.Math.RotateAround;
var RotateAround4 = function(centerX, centerY, angle, pathData) {
  var point = { x: 0, y: 0 };
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    point.x = pathData[i];
    point.y = pathData[i + 1];
    PointRotateAround(point, centerX, centerY, angle);
    pathData[i] = point.x;
    pathData[i + 1] = point.y;
  }
  return pathData;
};
var RotateAround_default = RotateAround4;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/Scale.js
var Scale = function(centerX, centerY, scaleX, scaleY, pathData) {
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    var x = pathData[i] - centerX;
    var y = pathData[i + 1] - centerY;
    x *= scaleX;
    y *= scaleY;
    pathData[i] = x + centerX;
    pathData[i + 1] = y + centerY;
  }
  return pathData;
};
var Scale_default2 = Scale;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/Offset.js
var Offset = function(x, y, pathData) {
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    pathData[i] += x;
    pathData[i + 1] += y;
  }
  return pathData;
};
var Offset_default = Offset;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/TransformPointsMethods.js
var DegToRad5 = Phaser.Math.DegToRad;
var PointRotateAround2 = Phaser.Math.RotateAround;
var TransformPointsMethods_default = {
  rotateAround(centerX, centerY, angle) {
    if (this.pathData.length === 0) {
      return this;
    }
    angle = DegToRad5(angle);
    RotateAround_default(centerX, centerY, angle, this.pathData);
    var pathDataCnt2 = this.pathData.length;
    this.lastPointX = this.pathData[pathDataCnt2 - 2];
    this.lastPointY = this.pathData[pathDataCnt2 - 1];
    return this;
  },
  scale(centerX, centerY, scaleX, scaleY) {
    if (this.pathData.length === 0) {
      return this;
    }
    Scale_default2(centerX, centerY, scaleX, scaleY, this.pathData);
    this.lastPointX = this.pathData[pathDataCnt - 2];
    this.lastPointY = this.pathData[pathDataCnt - 1];
    return this;
  },
  offset(x, y) {
    Offset_default(x, y, this.pathData);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/array/Copy.js
var Copy = function(dest, src, startIdx, endIdx) {
  if (startIdx === void 0) {
    startIdx = 0;
  }
  ;
  if (endIdx === void 0) {
    endIdx = src.length;
  }
  dest.length = endIdx - startIdx;
  for (var i = 0, len = dest.length; i < len; i++) {
    dest[i] = src[i + startIdx];
  }
  return dest;
};
var Copy_default = Copy;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/SavePathDataMethods.js
var SavePathDataMethods_default = {
  savePathData() {
    if (this.pathDataSaved) {
      return this;
    }
    this.pathDataSave = [...this.pathData];
    this.pathData.length = 0;
    this.pathDataSaved = true;
    return this;
  },
  restorePathData() {
    if (!this.pathDataSaved) {
      return this;
    }
    Copy_default(this.pathData, this.pathDataSave);
    this.pathDataSave = void 0;
    this.pathDataSaved = false;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/PathSegmentMethods.js
var DistanceBetween = Phaser.Math.Distance.Between;
var Wrap = Phaser.Math.Wrap;
var Linear2 = Phaser.Math.Linear;
var AppendFromPathSegment = function(srcPathData, accumulationLengths, startT, endT, destPathData) {
  if (endT === void 0) {
    endT = startT;
    startT = 0;
  }
  startT = WrapT(startT);
  endT = WrapT(endT);
  if (startT === endT) {
    return;
  }
  var totalPathLength = accumulationLengths[accumulationLengths.length - 1];
  var startL = totalPathLength * startT;
  var endL = totalPathLength * endT;
  if (startT < endT) {
    AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData);
  } else {
    AddPathSegment(srcPathData, accumulationLengths, startL, totalPathLength, destPathData);
    AddPathSegment(srcPathData, accumulationLengths, 0, endL, destPathData);
  }
  DuplicateLast_default(destPathData);
};
var AddPathSegment = function(srcPathData, accumulationLengths, startL, endL, destPathData) {
  var skipState = startL > 0;
  for (var i = 0, cnt = accumulationLengths.length; i < cnt; i++) {
    var pIdx = i * 2;
    var d = accumulationLengths[i];
    if (skipState) {
      if (d < startL) {
        continue;
      } else if (d == startL) {
        skipState = false;
      } else {
        var deltaD = d - accumulationLengths[i - 1];
        var t = 1 - (d - startL) / deltaD;
        destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
        destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
        skipState = false;
      }
    }
    if (d <= endL) {
      destPathData.push(srcPathData[pIdx]);
      destPathData.push(srcPathData[pIdx + 1]);
      if (d === endL) {
        break;
      }
    } else {
      var deltaD = d - accumulationLengths[i - 1];
      var t = 1 - (d - endL) / deltaD;
      destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
      destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
      break;
    }
  }
};
var GetInterpolation = function(pathData, i0, i1, t) {
  var p0 = pathData[i0], p1 = pathData[i1];
  return Linear2(p0, p1, t);
};
var WrapT = function(t) {
  if (t === 0) {
    return 0;
  } else if (t % 1 === 0) {
    return 1;
  }
  return Wrap(t, 0, 1);
};
var PathSegmentMethods_default = {
  updateAccumulationLengths() {
    if (this.accumulationLengths == null) {
      this.accumulationLengths = [];
    } else if (this.accumulationLengths.length === this.pathData.length / 2) {
      return this;
    }
    var accumulationLengths = this.accumulationLengths;
    var pathData = this.pathData;
    var prevX, prevY, x, y;
    var d, accumulationLength = 0;
    for (var i = 0, cnt = pathData.length; i < cnt; i += 2) {
      x = pathData[i];
      y = pathData[i + 1];
      d = prevX === void 0 ? 0 : DistanceBetween(prevX, prevY, x, y);
      accumulationLength += d;
      accumulationLengths.push(accumulationLength);
      prevX = x;
      prevY = y;
    }
    this.totalPathLength = accumulationLength;
    return this;
  },
  setDisplayPathSegment(startT, endT) {
    if (!this.pathDataSaved) {
      this.updateAccumulationLengths();
      this.savePathData();
    }
    this.pathData.length = 0;
    AppendFromPathSegment(this.pathDataSave, this.accumulationLengths, startT, endT, this.pathData);
    return this;
  },
  appendFromPathSegment(src, startT, endT) {
    if (startT === void 0) {
      this.pathData.push(...src.pathData);
    } else {
      src.updateAccumulationLengths();
      AppendFromPathSegment(src.pathData, src.accumulationLengths, startT, endT, this.pathData);
    }
    this.firstPointX = this.pathData[0];
    this.firstPointY = this.pathData[1];
    this.lastPointX = this.pathData[this.pathData.length - 2];
    this.lastPointY = this.pathData[this.pathData.length - 1];
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/GraphicsMethods.js
var GraphicsMethods_default = {
  draw(graphics, isFill, isStroke) {
    var points = this.toPoints();
    if (isFill) {
      graphics.fillPoints(points, this.closePath, this.closePath);
    }
    if (isStroke) {
      graphics.strokePoints(points, this.closePath, this.closePath);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/ToPoints.js
var ToPoints = function(pathData, points) {
  if (points === void 0) {
    points = [];
  }
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    points.push({
      x: pathData[i],
      y: pathData[i + 1]
    });
  }
  return points;
};
var ToPoints_default = ToPoints;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/ToPolygon.js
var Polygon = Phaser.Geom.Polygon;
var ToPolygon = function(pathData, polygon) {
  if (polygon === void 0) {
    polygon = new Polygon();
  }
  polygon.setTo(pathData);
  return polygon;
};
var ToPolygon_default = ToPolygon;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/PathDataBuilder.js
var PathDataBuilder = class {
  constructor(pathData) {
    if (pathData === void 0) {
      pathData = [];
    }
    this.pathData = pathData;
    this.closePath = false;
    this.setIterations(32);
    this.firstPointX = void 0;
    this.firstPointY = void 0;
    this.lastPointX = void 0;
    this.lastPointY = void 0;
    this.accumulationLengths = void 0;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  toPoints() {
    return ToPoints_default(this.pathData);
  }
  toPolygon(polygon) {
    return ToPolygon_default(this.pathData, polygon);
  }
};
Object.assign(
  PathDataBuilder.prototype,
  AddPathMethods_default,
  TransformPointsMethods_default,
  SavePathDataMethods_default,
  PathSegmentMethods_default,
  GraphicsMethods_default
);
var PathDataBuilder_default = PathDataBuilder;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/Lines.js
var Lines = class extends PathBase_default {
  constructor() {
    super();
    this.builder = new PathDataBuilder_default(this.pathData);
  }
  get iterations() {
    return this.builder.iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this.builder.iterations !== value;
    this.builder.setIterations(value);
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  get lastPointX() {
    return this.builder.lastPointX;
  }
  get lastPointY() {
    return this.builder.lastPointY;
  }
  start() {
    this.builder.start();
    this.dirty = true;
    return this;
  }
  startAt(x, y) {
    this.builder.startAt(x, y);
    this.dirty = true;
    return this;
  }
  lineTo(x, y, relative) {
    this.builder.lineTo(x, y, relative);
    this.dirty = true;
    return this;
  }
  verticalLineTo(x, relative) {
    this.builder.verticalLineTo(x, relative);
    this.dirty = true;
    return this;
  }
  horizontalLineTo(y, relative) {
    this.builder.horizontalLineTo(y, relative);
    this.dirty = true;
    return this;
  }
  ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
    this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);
    this.dirty = true;
    return this;
  }
  arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
    this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);
    this.dirty = true;
    return this;
  }
  quadraticBezierTo(cx, cy, x, y) {
    this.builder.quadraticBezierTo(cx, cy, x, y);
    this.dirty = true;
    return this;
  }
  cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
    this.builder.cubicBezierTo(cx0, cy0, cx1, cy1, x, y);
    this.dirty = true;
    return this;
  }
  catmullRomTo(...points) {
    this.builder.catmullRomTo(...points);
    this.dirty = true;
    return this;
  }
  close() {
    this.builder.close();
    this.closePath = this.builder.closePath;
    this.dirty = true;
    return this;
  }
  end() {
    this.builder.end();
    this.dirty = true;
    return this;
  }
  rotateAround(centerX, centerY, angle) {
    this.builder.rotateAround(centerX, centerY, angle);
    this.dirty = true;
    return this;
  }
  scale(centerX, centerY, scaleX, scaleY) {
    this.builder.scale(centerX, centerY, scaleX, scaleY);
    this.dirty = true;
    return this;
  }
  offset(x, y) {
    this.builder.offset(x, y);
    this.dirty = true;
    return this;
  }
  toPolygon(polygon) {
    return this.builder.toPolygon(polygon);
  }
  appendPathFrom(src, startT, endT) {
    this.builder.appendFromPathSegment(src.builder, startT, endT);
    return this;
  }
  copyPathFrom(src, startT, endT) {
    this.builder.clear().appendFromPathSegment(src.builder, startT, endT);
    return this;
  }
  setDisplayPathSegment(startT, endT) {
    this.builder.setDisplayPathSegment(startT, endT);
    return this;
  }
};
var Lines_default = Lines;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/rectangle/Rectangle.js
var GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
var Rectangle3 = class extends BaseGeom_default {
  constructor(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = width;
    }
    super();
    this.pathData = [];
    this.closePath = true;
    this.setTopLeftPosition(x, y);
    this.setSize(width, height);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.dirty = this.dirty || this._x !== value;
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.dirty = this.dirty || this._y !== value;
    this._y = value;
  }
  setTopLeftPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.dirty = this.dirty || this._width !== value;
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.dirty = this.dirty || this._height !== value;
    this._height = value;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  get centerX() {
    return this.x + this.width / 2;
  }
  set centerX(value) {
    this.x = value - this.width / 2;
  }
  get centerY() {
    return this.y + this.height / 2;
  }
  set centerY(value) {
    this.y = value - this.height / 2;
  }
  setCenterPosition(x, y) {
    this.centerX = x;
    this.centerY = y;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    var x0 = this.x, x1 = x0 + this.width, y0 = this.y, y1 = y0 + this.height;
    this.pathData.push(x0, y0);
    this.pathData.push(x1, y0);
    this.pathData.push(x1, y1);
    this.pathData.push(x0, y1);
    this.pathData.push(x0, y0);
    super.updateData();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
    if (this.isFilled) {
      var fillTint = pipeline.fillTint;
      var fillTintColor = GetTint(this.fillColor, this.fillAlpha * alpha);
      fillTint.TL = fillTintColor;
      fillTint.TR = fillTintColor;
      fillTint.BL = fillTintColor;
      fillTint.BR = fillTintColor;
      pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
    }
    if (this.isStroked) {
      StrokePathWebGL_default(pipeline, this, alpha, dx, dy);
    }
  }
  canvasRender(ctx, dx, dy) {
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fillRect(-dx, -dy, this.width, this.height);
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.beginPath();
      ctx.rect(-dx, -dy, this.width, this.height);
      ctx.stroke();
    }
  }
};
var Rectangle_default = Rectangle3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/roundrectangle/RoundRectangle.js
var GetValue16 = Phaser.Utils.Objects.GetValue;
var RoundRectangle = class extends PathBase_default {
  constructor(x, y, width, height, radius, iterations) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = width;
    }
    if (radius === void 0) {
      radius = 0;
    }
    if (iterations === void 0) {
      iterations = 6;
    }
    super();
    this.setTopLeftPosition(x, y);
    this.setSize(width, height);
    this.setRadius(radius);
    this.setIterations(iterations);
    this.closePath = true;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.dirty = this.dirty || this._x !== value;
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.dirty = this.dirty || this._y !== value;
    this._y = value;
  }
  setTopLeftPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.dirty = this.dirty || this._width !== value;
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.dirty = this.dirty || this._height !== value;
    this._height = value;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  get centerX() {
    return this.x + this.width / 2;
  }
  set centerX(value) {
    this.x = value - this.width / 2;
  }
  get centerY() {
    return this.y + this.height / 2;
  }
  set centerY(value) {
    this.y = value - this.height / 2;
  }
  setCenterPosition(x, y) {
    this.centerX = x;
    this.centerY = y;
    return this;
  }
  get radiusTL() {
    return this._radiusTL;
  }
  set radiusTL(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusTL !== value || this._convexTL !== isConvex;
    this._convexTL = isConvex;
    this._radiusTL = Math.abs(value);
  }
  get radiusTR() {
    return this._radiusTR;
  }
  set radiusTR(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusTR !== value || this._convexTR !== isConvex;
    this._convexTR = isConvex;
    this._radiusTR = Math.abs(value);
  }
  get radiusBL() {
    return this._radiusBL;
  }
  set radiusBL(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusBL !== value || this._convexBL !== isConvex;
    this._convexBL = isConvex;
    this._radiusBL = Math.abs(value);
  }
  get radiusBR() {
    return this._radiusBR;
  }
  set radiusBR(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusBR !== value || this._convexBR !== isConvex;
    this._convexBR = isConvex;
    this._radiusBR = Math.abs(value);
  }
  get radius() {
    return Math.max(this.radiusTL, this.radiusTR, this.radiusBL, this.radiusBR);
  }
  set radius(value) {
    if (typeof value === "number") {
      this.radiusTL = value;
      this.radiusTR = value;
      this.radiusBL = value;
      this.radiusBR = value;
    } else {
      this.radiusTL = GetValue16(value, "tl", 0);
      this.radiusTR = GetValue16(value, "tr", 0);
      this.radiusBL = GetValue16(value, "bl", 0);
      this.radiusBR = GetValue16(value, "br", 0);
    }
  }
  setRadius(radius) {
    if (radius === void 0) {
      radius = 0;
    }
    this.radius = radius;
    return this;
  }
  get iterations() {
    return this._iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this._iterations !== value;
    this._iterations = value;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  updateData() {
    var pathData = this.pathData;
    pathData.length = 0;
    var width = this.width, height = this.height, radius, iterations = this.iterations + 1;
    radius = this.radiusTL;
    if (radius > 0) {
      if (this._convexTL) {
        var centerX = radius;
        var centerY = radius;
        ArcTo_default(centerX, centerY, radius, radius, 180, 270, false, iterations, pathData);
      } else {
        var centerX = 0;
        var centerY = 0;
        ArcTo_default(centerX, centerY, radius, radius, 90, 0, true, iterations, pathData);
      }
    } else {
      LineTo_default(0, 0, pathData);
    }
    radius = this.radiusTR;
    if (radius > 0) {
      if (this._convexTR) {
        var centerX = width - radius;
        var centerY = radius;
        ArcTo_default(centerX, centerY, radius, radius, 270, 360, false, iterations, pathData);
      } else {
        var centerX = width;
        var centerY = 0;
        ArcTo_default(centerX, centerY, radius, radius, 180, 90, true, iterations, pathData);
      }
    } else {
      LineTo_default(width, 0, pathData);
    }
    radius = this.radiusBR;
    if (radius > 0) {
      if (this._convexBR) {
        var centerX = width - radius;
        var centerY = height - radius;
        ArcTo_default(centerX, centerY, radius, radius, 0, 90, false, iterations, pathData);
      } else {
        var centerX = width;
        var centerY = height;
        ArcTo_default(centerX, centerY, radius, radius, 270, 180, true, iterations, pathData);
      }
    } else {
      LineTo_default(width, height, pathData);
    }
    radius = this.radiusBL;
    if (radius > 0) {
      if (this._convexBL) {
        var centerX = radius;
        var centerY = height - radius;
        ArcTo_default(centerX, centerY, radius, radius, 90, 180, false, iterations, pathData);
      } else {
        var centerX = 0;
        var centerY = height;
        ArcTo_default(centerX, centerY, radius, radius, 360, 270, true, iterations, pathData);
      }
    } else {
      LineTo_default(0, height, pathData);
    }
    pathData.push(pathData[0], pathData[1]);
    Offset_default(this.x, this.y, pathData);
    super.updateData();
    return this;
  }
};
var RoundRectangle_default = RoundRectangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/triangle/Triangle.js
var GetTint2 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
var Triangle = class extends BaseGeom_default {
  constructor(x0, y0, x1, y1, x2, y2) {
    if (x0 === void 0) {
      x0 = 0;
    }
    if (y0 === void 0) {
      y0 = 0;
    }
    if (x1 === void 0) {
      x1 = 0;
    }
    if (y1 === void 0) {
      y1 = 0;
    }
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    super();
    this.pathData = [];
    this.closePath = true;
    this.setP0(x0, y0);
    this.setP1(x1, y1);
    this.setP2(x2, y2);
  }
  get x0() {
    return this._x0;
  }
  set x0(value) {
    this.dirty = this.dirty || this._x0 !== value;
    this._x0 = value;
  }
  get y0() {
    return this._y0;
  }
  set y0(value) {
    this.dirty = this.dirty || this._y0 !== value;
    this._y0 = value;
  }
  setP0(x, y) {
    this.x0 = x;
    this.y0 = y;
    return this;
  }
  get x1() {
    return this._x1;
  }
  set x1(value) {
    this.dirty = this.dirty || this._x1 !== value;
    this._x1 = value;
  }
  get y1() {
    return this._y1;
  }
  set y1(value) {
    this.dirty = this.dirty || this._y1 !== value;
    this._y1 = value;
  }
  setP1(x, y) {
    this.x1 = x;
    this.y1 = y;
    return this;
  }
  get x2() {
    return this._x2;
  }
  set x2(value) {
    this.dirty = this.dirty || this._x2 !== value;
    this._x2 = value;
  }
  get y2() {
    return this._y2;
  }
  set y2(value) {
    this.dirty = this.dirty || this._y2 !== value;
    this._y2 = value;
  }
  setP2(x, y) {
    this.dirty = this.dirty || this.x2 !== x || this.y2 !== y;
    this.x2 = x;
    this.y2 = y;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    this.pathData.push(this.x0, this.y0);
    this.pathData.push(this.x1, this.y1);
    this.pathData.push(this.x2, this.y2);
    this.pathData.push(this.x0, this.y0);
    super.updateData();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
    if (this.isFilled) {
      var fillTintColor = GetTint2(this.fillColor, this.fillAlpha * alpha);
      var x0 = this.x0 - dx;
      var y0 = this.y0 - dy;
      var x1 = this.x1 - dx;
      var y1 = this.y1 - dy;
      var x2 = this.x2 - dx;
      var y2 = this.y2 - dy;
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
    }
    if (this.isStroked) {
      StrokePathWebGL_default(pipeline, this, alpha, dx, dy);
    }
  }
  canvasRender(ctx, dx, dy) {
    var x1 = this.x1 - dx;
    var y1 = this.y1 - dy;
    var x2 = this.x2 - dx;
    var y2 = this.y2 - dy;
    var x3 = this.x3 - dx;
    var y3 = this.y3 - dy;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fill();
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.stroke();
    }
  }
};
var Triangle_default = Triangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/customshapes/ShapesUpdateMethods.js
var ShapeClasses = {
  arc: Arc_default,
  circle: Circle_default,
  curve: Curve_default,
  ellipse: Ellipse_default,
  line: Line_default,
  lines: Lines_default,
  rectangle: Rectangle_default,
  roundRectangle: RoundRectangle_default,
  triangle: Triangle_default
};
var GetValue17 = Phaser.Utils.Objects.GetValue;
var IsPlainObject4 = Phaser.Utils.Objects.IsPlainObject;
var ClearAll = function() {
  var shapes = this.getShapes();
  for (var i = 0, cnt = shapes.length; i < cnt; i++) {
    shapes[i].lineStyle().fillStyle();
  }
};
var ShapesUpdateMethods_default = {
  createShape(shapeType, name) {
    var ShapeClass = ShapeClasses[shapeType];
    var shape = new ShapeClass();
    if (name) {
      shape.setName(name);
    }
    return shape;
  },
  buildShapes(config) {
    var createCallback = GetValue17(config, "create", void 0);
    if (IsPlainObject4(createCallback)) {
      var shapes = createCallback;
      for (var shapeType in shapes) {
        var name = shapes[shapeType];
        switch (typeof name) {
          case "number":
            for (var i = 0; i < name; i++) {
              this.addShape(this.createShape(shapeType));
            }
            break;
          case "string":
            this.addShape(this.createShape(shapeType, name));
            break;
          default:
            var names = name;
            for (var i = 0, cnt = names.length; i < cnt; i++) {
              this.addShape(this.createShape(shapeType, names[i]));
            }
            break;
        }
      }
    } else if (Array.isArray(createCallback)) {
      var shapes = createCallback;
      for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        var shape = shapes[i];
        this.addShape(this.createShape(shape.type, shape.name));
      }
    } else if (typeof createCallback === "function") {
      createCallback.call(this);
    }
    this.setUpdateShapesCallback(GetValue17(config, "update"));
  },
  setUpdateShapesCallback(callback) {
    if (callback === void 0) {
      callback = ClearAll;
    }
    this.dirty = this.dirty || this.updateCallback !== callback;
    this.updateCallback = callback;
    return this;
  },
  updateShapes() {
    this.updateCallback.call(this);
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/position/WorldXYToGameObjectLocalXY.js
var TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;
var TransformXY = Phaser.Math.TransformXY;
var WorldXYToGameObjectLocalXY = function(gameObject, worldX, worldY, camera, out) {
  if (camera === void 0) {
    camera = gameObject.scene.cameras.main;
  }
  if (out === void 0) {
    out = {};
  } else if (out === true) {
    out = globOut;
  }
  var csx = camera.scrollX;
  var csy = camera.scrollY;
  var px = worldX + csx * gameObject.scrollFactorX - csx;
  var py = worldY + csy * gameObject.scrollFactorY - csy;
  if (gameObject.parentContainer) {
    if (tempMatrix === void 0) {
      tempMatrix = new TransformMatrix();
      parentMatrix = new TransformMatrix();
    }
    gameObject.getWorldTransformMatrix(tempMatrix, parentMatrix);
    tempMatrix.applyInverse(px, py, out);
  } else {
    TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, out);
  }
  out.x += gameObject.displayOriginX;
  out.y += gameObject.displayOriginY;
  return out;
};
var tempMatrix;
var parentMatrix;
var globOut = {};
var WorldXYToGameObjectLocalXY_default = WorldXYToGameObjectLocalXY;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/customshapes/CustomShapes.js
var GetValue18 = Phaser.Utils.Objects.GetValue;
var IsPlainObject5 = Phaser.Utils.Objects.IsPlainObject;
var CustomShapes = class extends BaseShapes_default {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject5(x)) {
      config = x;
      x = GetValue18(config, "x", 0);
      y = GetValue18(config, "y", 0);
      width = GetValue18(config, "width", 2);
      height = GetValue18(config, "height", 2);
    }
    super(scene, x, y, width, height);
    this.type = GetValue18(config, "type", "rexCustomShapes");
    this.buildShapes(config);
  }
  get centerX() {
    return this.width / 2;
  }
  get centerY() {
    return this.height / 2;
  }
  worldToLocalXY(worldX, worldY, camera, out) {
    if (typeof camera === "boolean") {
      out = camera;
      camera = void 0;
    }
    return WorldXYToGameObjectLocalXY_default(this, worldX, worldY, camera, out);
  }
};
Object.assign(
  CustomShapes.prototype,
  ShapesUpdateMethods_default
);
var CustomShapes_default = CustomShapes;

// node_modules/phaser3-rex-plugins/plugins/utils/progressvalue/ProgressValueMethods.js
var Linear3 = Phaser.Math.Linear;
var Percent = Phaser.Math.Percent;
var ProgressValueMethods_default = {
  setValue(value, min, max) {
    if (value === void 0 || value === null) {
      return this;
    }
    if (min !== void 0) {
      value = Percent(value, min, max);
    }
    this.value = value;
    return this;
  },
  addValue(inc, min, max) {
    if (min !== void 0) {
      inc = Percent(inc, min, max);
    }
    this.value += inc;
    return this;
  },
  getValue(min, max) {
    var value = this.value;
    if (min !== void 0 && max !== void 0) {
      value = Linear3(min, max, value);
    }
    return value;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/ease/EaseValueMethods.js
var Percent2 = Phaser.Math.Percent;
var EaseValueMethods_default = {
  setEaseValuePropName(name) {
    this.easeValuePropName = name;
    return this;
  },
  setEaseValueDuration(duration) {
    this.easeValueDuration = duration;
    return this;
  },
  setEaseValueFunction(ease) {
    this.easeFunction = ease;
    return this;
  },
  stopEaseValue() {
    if (this.easeValueTask) {
      this.easeValueTask.stop();
    }
    return this;
  },
  easeValueTo(value, min, max) {
    if (value === void 0 || value === null) {
      return this;
    }
    if (min !== void 0) {
      value = Percent2(value, min, max);
    }
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeValueTask.restart({
      key: this.easeValuePropName,
      to: value,
      duration: this.easeValueDuration,
      ease: this.easeFunction
    });
    return this;
  },
  easeValueRepeat(from, to, repeat, repeatDelay) {
    if (repeat === void 0) {
      repeat = -1;
    }
    if (repeatDelay === void 0) {
      repeatDelay = 0;
    }
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeValueTask.restart({
      key: this.easeValuePropName,
      from,
      to,
      duration: this.easeValueDuration,
      ease: this.easeFunction,
      repeat,
      repeatDelay
    });
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/progressbase/ProgressBase.js
var GetValue19 = Phaser.Utils.Objects.GetValue;
var Clamp3 = Phaser.Math.Clamp;
function ProgressBase_default(BaseClass) {
  class ProgressBase extends BaseClass {
    bootProgressBase(config) {
      this.eventEmitter = GetValue19(config, "eventEmitter", this);
      var callback = GetValue19(config, "valuechangeCallback", null);
      if (callback !== null) {
        var scope = GetValue19(config, "valuechangeCallbackScope", void 0);
        this.eventEmitter.on("valuechange", callback, scope);
      }
      this.setEaseValuePropName("value").setEaseValueDuration(GetValue19(config, "easeValue.duration", 0)).setEaseValueFunction(GetValue19(config, "easeValue.ease", "Linear"));
      return this;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      value = Clamp3(value, 0, 1);
      var oldValue = this._value;
      var valueChanged = oldValue != value;
      this.dirty = this.dirty || valueChanged;
      this._value = value;
      if (valueChanged) {
        this.eventEmitter.emit("valuechange", this._value, oldValue, this.eventEmitter);
      }
    }
  }
  Object.assign(
    ProgressBase.prototype,
    ProgressValueMethods_default,
    EaseValueMethods_default
  );
  return ProgressBase;
}

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/customprogress/CustomProgress.js
var GetValue20 = Phaser.Utils.Objects.GetValue;
var IsPlainObject6 = Phaser.Utils.Objects.IsPlainObject;
var CustomProgress = class extends ProgressBase_default(CustomShapes_default) {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject6(x)) {
      config = x;
      x = GetValue20(config, "x", 0);
      y = GetValue20(config, "y", 0);
      width = GetValue20(config, "width", 2);
      height = GetValue20(config, "height", 2);
    }
    if (config === void 0) {
      config = {};
    }
    if (!config.type) {
      config.type = "rexCustomProgress";
    }
    super(scene, x, y, width, height, config);
    this.bootProgressBase(config);
    this.setValue(GetValue20(config, "value", 0));
  }
  get centerX() {
    return this.width / 2;
    ;
  }
  get centerY() {
    return this.height / 2;
  }
  get radius() {
    return Math.min(this.centerX, this.centerY);
  }
};
var CustomProgress_default = CustomProgress;

// node_modules/phaser3-rex-plugins/plugins/customprogress.js
var customprogress_default = CustomProgress_default;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddWipeModes.js
var CreateMask = function(scene) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: [
      { name: "rect", type: "rectangle" }
    ],
    update: function() {
      var rect = this.getShape("rect").fillStyle(16777215);
      var t = 1 - this.value;
      switch (this.wipeMode) {
        case "right":
          rect.setSize(this.width * t, this.height).setTopLeftPosition(this.width - rect.width, 0);
          break;
        case "left":
          rect.setSize(this.width * t, this.height).setTopLeftPosition(0, 0);
          break;
        case "down":
          rect.setSize(this.width, this.height * t).setTopLeftPosition(0, this.height - rect.height);
          break;
        case "up":
          rect.setSize(this.width, this.height * t).setTopLeftPosition(0, 0);
          break;
      }
    }
  });
  return maskGameObject;
};
var AddWipeModes = function(image) {
  var maskGameObject = CreateMask(image.scene);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(WipeRight, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "right";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(WipeLeft, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "left";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(WipeDown, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "down";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(WipeUp, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "up";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddWipeModes_default = AddWipeModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddIrisModes.js
var CreateMask2 = function(scene) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: [
      { name: "rect", type: "rectangle" }
    ],
    update: function() {
      this.getShape("rect").fillStyle(16777215).setSize(this.width * this.value, this.height * this.value).setCenterPosition(this.centerX, this.centerY);
    }
  });
  return maskGameObject;
};
var AddIrisModes = function(image) {
  var maskGameObject = CreateMask2(image.scene);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(IrisOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(IrisIn, {
    ease: "Linear",
    dir: "in",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setNextImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(1 - t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(IrisInOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
      parent.setCurrentImageMaskEnable(true);
      parent.setNextImageMaskEnable(true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddIrisModes_default = AddIrisModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddPieModes.js
var CreateMask3 = function(scene) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: [
      { name: "pie", type: "arc" }
    ],
    update: function() {
      var radius = Math.max(this.width, this.height) * 2;
      var deltaAngle = 90 * this.value;
      this.getShape("pie").fillStyle(16777215).setCenterPosition(this.centerX, 0).setRadius(radius).setAngle(90 - deltaAngle, 90 + deltaAngle).setPie();
    }
  });
  return maskGameObject;
};
var AddPieModes = function(image) {
  var maskGameObject = CreateMask3(image.scene);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(PieOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(PieIn, {
    ease: "Linear",
    dir: "in",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setNextImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(1 - t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(PieInOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
      parent.setCurrentImageMaskEnable(true);
      parent.setNextImageMaskEnable(true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddPieModes_default = AddPieModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddBlindsModes.js
var CreateMask4 = function(scene, columns) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      rectangle: columns
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeWidth = this.width / columns;
      for (var i = 0; i < columns; i++) {
        shapes[i].fillStyle(16777215).setSize(shapeWidth * this.value, this.height).setTopLeftPosition(shapeWidth * i, 0);
      }
    }
  });
  return maskGameObject;
};
var AddBlindsModes = function(image) {
  var maskGameObject = CreateMask4(image.scene, 10);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Blinds, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddBlindsModes_default = AddBlindsModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddSquaresModes.js
var CreateMask5 = function(scene, columns, rows) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      rectangle: columns * rows
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeWidth = this.width / columns, shapeHeight = this.height / rows;
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          shapes[c * rows + r].fillStyle(16777215).setSize(shapeWidth * this.value, shapeHeight * this.value).setCenterPosition(shapeWidth * (c + 0.5), shapeHeight * (r + 0.5));
        }
      }
    }
  });
  return maskGameObject;
};
var AddSquaresModes = function(image) {
  var maskGameObject = CreateMask5(image.scene, Math.ceil(image.width / 40), Math.ceil(image.height / 40));
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Squares, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddSquaresModes_default = AddSquaresModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddDiamondsMode.js
var CreateMask6 = function(scene, columns, rows) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      lines: columns * rows
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeHalfWidth = this.width / (columns - 1), shapeHelfHeight = this.height / rows;
      var shapeHeight = shapeHelfHeight * 2;
      var halfWidth = shapeHalfWidth * this.value, halfHeight = shapeHelfHeight * this.value;
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          var centerX = c * shapeHalfWidth;
          var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
          shapes[c * rows + r].fillStyle(16777215).start(centerX + halfWidth, centerY).lineTo(centerX, centerY + halfHeight).lineTo(centerX - halfWidth, centerY).lineTo(centerX, centerY - halfHeight).lineTo(centerX + halfWidth, centerY).close();
        }
      }
    }
  });
  return maskGameObject;
};
var AddDiamondsMode = function(image) {
  var maskGameObject = CreateMask6(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Diamonds, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddDiamondsMode_default = AddDiamondsMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddCirclesMode.js
var CreateMask7 = function(scene, columns, rows) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      circle: columns * rows
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeHalfWidth = this.width / (columns - 1), shapeHelfHeight = this.height / rows;
      var shapeHeight = shapeHelfHeight * 2;
      var radius = Math.max(shapeHalfWidth, shapeHelfHeight) * this.value;
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          var centerX = c * shapeHalfWidth;
          var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
          shapes[c * rows + r].fillStyle(16777215).setCenterPosition(centerX, centerY).setRadius(radius);
        }
      }
    }
  });
  return maskGameObject;
};
var AddCirclesMode = function(image) {
  var maskGameObject = CreateMask7(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Circles, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddCirclesMode_default = AddCirclesMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddCurtainMode.js
var CreateMask8 = function(scene, columns) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      lines: columns
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeWidth = this.width / columns;
      var radius = shapeWidth / 2;
      for (var i = 0; i < columns; i++) {
        var leftX = shapeWidth * i;
        var bottomY = this.height * this.value;
        var centerX = leftX + radius;
        shapes[i].fillStyle(16777215).start(leftX, 0).horizontalLineTo(bottomY).arc(centerX, bottomY, radius, 180, 0, true).horizontalLineTo(-bottomY).lineTo(leftX, 0).close();
      }
    }
  });
  return maskGameObject;
};
var AddCurtainMode = function(image) {
  var maskGameObject = CreateMask8(image.scene, 10);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Curtain, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
      parent.setCurrentImageMaskEnable(true, true);
      parent.setNextImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(t);
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default2(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(t);
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddCurtainMode_default = AddCurtainMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddPixellateMode.js
var AddPixellateMode = function(image) {
  image.addTransitionMode(Pixellate, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setChildVisible(nextImage, false);
      currentImage.effect = currentImage.preFX.addPixelate(0);
      nextImage.effect = nextImage.preFX.addPixelate(0);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      if (t < 0.5) {
        t = Yoyo_default2(t);
        var maxAmount = Math.min(currentImage.width, currentImage.height) / 5;
        currentImage.effect.amount = Math.ceil(maxAmount * t);
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        if (!nextImage.visible) {
          parent.setChildVisible(nextImage, true);
        }
        t = Yoyo_default2(t);
        var maxAmount = Math.min(nextImage.width, nextImage.height) / 5;
        nextImage.effect.amount = Math.ceil(maxAmount * t);
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      currentImage.preFX.remove(currentImage.effect);
      delete currentImage.effect;
      parent.setChildVisible(currentImage, true);
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  });
};
var AddPixellateMode_default = AddPixellateMode;

// node_modules/phaser3-rex-plugins/plugins/shaders/utils/noise/Perlin.js
var frag = `vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
float Perlin(vec3 P) {
    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0); gx1 = fract(gx1);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}
float Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }
`;
var Perlin_default = frag;

// node_modules/phaser3-rex-plugins/plugins/shaders/dissolve/dissolve-frag.js
var frag2 = `#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
// Scene buffer
uniform sampler2D uMainSampler;
uniform sampler2D uMainSampler2;

uniform int resizeMode;
uniform float progress;
uniform float fromRatio;
uniform float toRatio;
varying vec2 outFragCoord;
// Effect parameters
uniform float noiseX;
uniform float noiseY;
uniform float noiseZ;
uniform float fromEdgeStart;
uniform float fromEdgeWidth;
uniform float toEdgeStart;
uniform float toEdgeWidth;

${Perlin_default}

vec4 getFromColor (vec2 uv) {
  return texture2D(uMainSampler, uv);
}

vec4 getToColor (vec2 uv) {
  if (resizeMode == 2) {
    //  cover
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));
  } else if (resizeMode == 1) {
    //  contain
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));
  } else {
    //  stretch
    return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));
  }
}

vec4 transition (vec2 uv) {    
  vec4 colorFront = getFromColor(uv);
  vec4 colorTo = getToColor(uv);

  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0
    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))
    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;
  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)
    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));
  return colorResult;
}

void main () {
  vec2 uv = outFragCoord;
  gl_FragColor = transition(uv);
}
`;
var dissolve_frag_default = frag2;

// node_modules/phaser3-rex-plugins/plugins/shaders/dissolve/DissolvePostFxPipeline.js
var PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
var GetValue21 = Phaser.Utils.Objects.GetValue;
var Clamp4 = Phaser.Math.Clamp;
var DissolvePostFxPipeline = class extends PostFXPipeline {
  constructor(game) {
    super({
      name: "rexDissolvePostFx",
      game,
      renderTarget: true,
      fragShader: dissolve_frag_default
    });
    this._progress = 0;
    this.toFrame = null;
    this.targetTexture = null;
    this.resizeMode = 1;
    this.toRatio = 1;
    this.noiseX = 0;
    this.noiseY = 0;
    this.noiseZ = 0;
    this.fromEdgeStart = 0.01;
    this.fromEdgeWidth = 0.05;
    this.toEdgeStart = 0.01;
    this.toEdgeWidth = 0.05;
  }
  resetFromJSON(o) {
    this.setProgress(GetValue21(o, "progress", 0));
    this.setTransitionTargetTexture(GetValue21(o, "toTexture", "__DEFAULT"), GetValue21(o, "toFrame", void 0), GetValue21(o, "resizeMode", 1));
    this.setNoise(GetValue21(o, "noiseX", void 0), GetValue21(o, "noiseY", void 0), GetValue21(o, "noiseZ", void 0));
    this.setFromEdge(GetValue21(o, "fromEdgeStart", 0.01), GetValue21(o, "fromEdgeWidth", 0.05));
    this.setToEdge(GetValue21(o, "toEdgeStart", 0.01), GetValue21(o, "toEdgeWidth", 0.05));
    return this;
  }
  onBoot() {
  }
  onPreRender() {
    this.set1f("progress", this.progress);
    this.set1i("resizeMode", this.resizeMode);
    this.set1f("noiseX", this.noiseX);
    this.set1f("noiseY", this.noiseY);
    this.set1f("noiseZ", this.noiseZ);
    this.set1f("fromEdgeStart", this.fromEdgeStart);
    this.set1f("fromEdgeWidth", this.fromEdgeWidth);
    this.set1f("toEdgeStart", this.toEdgeStart);
    this.set1f("toEdgeWidth", this.toEdgeWidth);
  }
  onDraw(renderTarget) {
    this.set1f("fromRatio", renderTarget.width / renderTarget.height);
    this.set1f("toRatio", this.toRatio);
    this.set1i("uMainSampler2", 1);
    this.bindTexture(this.targetTexture, 1);
    this.bindAndDraw(renderTarget);
  }
  get progress() {
    return this._progress;
  }
  set progress(value) {
    this._progress = Clamp4(value, 0, 1);
  }
  setProgress(value) {
    this.progress = value;
    return this;
  }
  setTransitionTargetTexture(key2, frame, resizeMode) {
    if (key2 === void 0) {
      key2 = "__DEFAULT";
    }
    var phaserTexture = this.game.textures.getFrame(key2, frame);
    if (!phaserTexture) {
      phaserTexture = this.game.textures.getFrame("__DEFAULT");
    }
    this.toRatio = phaserTexture.width / phaserTexture.height;
    this.toFrame = phaserTexture;
    this.targetTexture = phaserTexture.glTexture;
    if (resizeMode !== void 0) {
      this.resizeMode = resizeMode;
    }
    return this;
  }
  setResizeMode(mode) {
    if (typeof mode === "string") {
      mode = ResizeMode[mode];
    }
    this.resizeMode = mode;
    return this;
  }
  setNoise(x, y, z) {
    if (x === void 0) {
      x = 4 + Math.random() * 6;
    }
    if (y === void 0) {
      y = 4 + Math.random() * 6;
    }
    if (z === void 0) {
      z = Math.random() * 10;
    }
    this.noiseX = x;
    this.noiseY = y;
    this.noiseZ = z;
    return this;
  }
  setFromEdge(edgeStart, edgeWidth) {
    this.fromEdgeStart = edgeStart;
    this.fromEdgeWidth = edgeWidth;
    return this;
  }
  setToEdge(edgeStart, edgeWidth) {
    this.toEdgeStart = edgeStart;
    this.toEdgeWidth = edgeWidth;
    return this;
  }
};
var ResizeMode = {
  stretch: 0,
  contain: 1,
  cover: 2
};
var DissolvePostFxPipeline_default = DissolvePostFxPipeline;

// node_modules/phaser3-rex-plugins/plugins/dissolvepipeline.js
var dissolvepipeline_default = DissolvePostFxPipeline_default;

// node_modules/phaser3-rex-plugins/plugins/utils/renderer/postfxpipeline/RegisterPostPipeline.js
var RegisterPostPipeline = function(game, postFxPipelineName, PostFxPipelineClass) {
  GetGame_default(game).renderer.pipelines.addPostPipeline(postFxPipelineName, PostFxPipelineClass);
};
var RegisterPostPipeline_default = RegisterPostPipeline;

// node_modules/phaser3-rex-plugins/plugins/utils/renderer/postfxpipeline/AddPostFxPipelineInstance.js
var AddPostFxPipelineInstance = function(gameObject, PostFxPipelineClass, config) {
  if (config === void 0) {
    config = {};
  }
  gameObject.setPostPipeline(PostFxPipelineClass);
  var pipeline = gameObject.postPipelines[gameObject.postPipelines.length - 1];
  pipeline.resetFromJSON(config);
  if (config.name) {
    pipeline.name = config.name;
  }
  return pipeline;
};
var AddPostFxPipelineInstance_default = AddPostFxPipelineInstance;

// node_modules/phaser3-rex-plugins/plugins/utils/renderer/postfxpipeline/RemovePostFxPipelineInstance.js
var SpliceOne = Phaser.Utils.Array.SpliceOne;
var RemovePostFxPipelineInstance = function(gameObject, PostFxPipelineClass, name) {
  if (name === void 0) {
    var pipelines = gameObject.postPipelines;
    for (var i = pipelines.length - 1; i >= 0; i--) {
      var instance = pipelines[i];
      if (instance instanceof PostFxPipelineClass) {
        instance.destroy();
        SpliceOne(pipelines, i);
      }
    }
  } else {
    var pipelines = gameObject.postPipelines;
    for (var i = 0, cnt = pipelines.length; i < cnt; i++) {
      var instance = pipelines[i];
      if (instance instanceof PostFxPipelineClass && instance.name === name) {
        instance.destroy();
        SpliceOne(pipelines, i);
      }
    }
  }
  gameObject.hasPostPipeline = gameObject.postPipelines.length > 0;
};
var RemovePostFxPipelineInstance_default = RemovePostFxPipelineInstance;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddDissolveMode.js
var AddDissolveMode = function(image) {
  RegisterPostPipeline_default(image.scene.game, "rexDissolvePostFx", dissolvepipeline_default);
  image.addTransitionMode(Dissolve, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      currentImage.effect = AddPostFxPipelineInstance_default(currentImage, dissolvepipeline_default);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      currentImage.effect.setProgress(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      RemovePostFxPipelineInstance_default(currentImage, dissolvepipeline_default);
      delete currentImage.effect;
    }
  });
};
var AddDissolveMode_default = AddDissolveMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddRevealModes.js
var WipeWidth = 0.1;
var DirLeftToRight = 0;
var DirTopToBottom = 0;
var DirRightToLeft = 1;
var DirBottomToTop = 1;
var AxisX = 0;
var AxisY = 1;
var AddRevealModes = function(image) {
  image.addTransitionMode(RevealRight, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirLeftToRight, AxisX);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  }).addTransitionMode(RevealLeft, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirRightToLeft, AxisX);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  }).addTransitionMode(RevealDown, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirTopToBottom, AxisY);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  }).addTransitionMode(RevealUp, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirBottomToTop, AxisY);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  });
};
var AddRevealModes_default = AddRevealModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/Modes.js
var Modes = [
  AddSlideAwayModes_default,
  AddSlideModes_default,
  AddPushModes_default,
  AddZoomModes_default,
  AddFadeModes_default,
  AddIrisModes_default,
  AddPieModes_default,
  AddWipeModes_default,
  AddBlindsModes_default,
  AddSquaresModes_default,
  AddDiamondsMode_default,
  AddCirclesMode_default,
  AddCurtainMode_default,
  AddPixellateMode_default,
  AddDissolveMode_default,
  AddRevealModes_default
];
var Modes_default = Modes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/TransitionImagePack.js
var TransitionImagePack = class extends transitionimage_default {
  constructor(scene, x, y, texture, frame, config) {
    super(scene, x, y, texture, frame, config);
    for (var i = 0, cnt = Modes_default.length; i < cnt; i++) {
      Modes_default[i](this);
    }
  }
};
var TransitionImagePack_default = TransitionImagePack;

export {
  IsSceneObject_default,
  GetGame_default,
  GetValue_default,
  DataMethods_default,
  FillPathWebGL_default,
  StrokePathWebGL_default,
  FillStyleCanvas_default,
  LineStyleCanvas_default,
  LineTo_default,
  ArcTo_default,
  EventEmitterMethods_default,
  GetDisplayWidth,
  GetDisplayHeight,
  GetBounds,
  GetTopLeft,
  GetTopRight,
  GetBottomLeft,
  GetCenter,
  DrawBounds_default,
  IsGameObject_default,
  IsLayerGameObject_default,
  SortGameObjectsByDepth_default,
  GetSceneObject_default,
  ComponentBase_default,
  TickTask_default,
  Timer_default,
  EaseValueTaskBase_default,
  Yoyo_default,
  IsKeyValueEqual_default,
  BaseShapes_default,
  Arc_default,
  Circle_default,
  Line_default,
  Copy_default,
  Lines_default,
  RoundRectangle_default,
  EaseValueTask_default,
  ProgressBase_default,
  GetParent,
  GetTopmostParent,
  Snapshot_default,
  ContainerLite_default,
  GetBoundsConfig_default,
  FitTo_default,
  CustomShapes_default,
  customprogress_default,
  DefaultMaskGraphics_default,
  FlipMethods_default,
  transitionimage_default,
  TransitionImagePack_default
};
//# sourceMappingURL=chunk-HBCBWOV5.js.map
